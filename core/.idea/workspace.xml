<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="c4a3720d-cc46-4ff2-90ff-a29ab3cd4cad" name="Default Changelist" comment="" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="ProjectId" id="1SbGU66ACUCRlk5TSbg3oCDIoDv" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="PropertiesComponent">
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="aspect.path.notification.shown" value="true" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="node.js.detected.package.eslint" value="true" />
    <property name="node.js.detected.package.tslint" value="true" />
    <property name="node.js.path.for.package.eslint" value="project" />
    <property name="node.js.path.for.package.tslint" value="project" />
    <property name="node.js.selected.package.eslint" value="(autodetect)" />
    <property name="node.js.selected.package.tslint" value="(autodetect)" />
    <property name="settings.editor.selected.configurable" value="preferences.editor" />
  </component>
  <component name="ReplState" timestamp="1578921317804">{:repl-history {:ide [], :local [{:command &quot;[\&quot;Brayan\&quot; \&quot;August\&quot;  \&quot;Brianna\&quot;     \&quot;Mya\&quot;       \&quot;Salma\&quot;                 \&quot;Barrett\&quot;                 \&quot;Mallory\&quot;                 \&quot;Jazlynn\&quot;                 \&quot;Julius\&quot;                 \&quot;Aliya\&quot;                 \&quot;Katelyn\&quot;                 \&quot;Dereon\&quot;                 \&quot;Courtney\&quot;                 \&quot;Christian\&quot;                 \&quot;Charity\&quot;                 \&quot;Erica\&quot;                 \&quot;Miya\&quot;                 \&quot;Javon\&quot;                 \&quot;Delilah\&quot;                 \&quot;Jaiden\&quot;]&quot;, :offset 42, :ns &quot;core.core&quot;} {:command &quot;(\&quot;Brayan\&quot; \&quot;August\&quot;  \&quot;Brianna\&quot;     \&quot;Mya\&quot;       \&quot;Salma\&quot;                 \&quot;Barrett\&quot;                 \&quot;Mallory\&quot;                 \&quot;Jazlynn\&quot;                 \&quot;Julius\&quot;                 \&quot;Aliya\&quot;                 \&quot;Katelyn\&quot;                 \&quot;Dereon\&quot;                 \&quot;Courtney\&quot;                 \&quot;Christian\&quot;                 \&quot;Charity\&quot;                 \&quot;Erica\&quot;                 \&quot;Miya\&quot;                 \&quot;Javon\&quot;                 \&quot;Delilah\&quot;                 \&quot;Jaiden\&quot;)&quot;, :offset 434, :ns &quot;core.core&quot;} {:command &quot;[\&quot;Brayan\&quot; \&quot;August\&quot; \&quot;Brianna\&quot; \&quot;Mya\&quot; \&quot;Salma\&quot; \&quot;Barrett\&quot; \&quot;Mallory\&quot; \&quot;Jazlynn\&quot; \&quot;Julius\&quot; \&quot;Aliya\&quot;\n \&quot;Katelyn\&quot; \&quot;Dereon\&quot; \&quot;Courtney\&quot; \&quot;Christian\&quot; \&quot;Charity\&quot; \&quot;Erica\&quot; \&quot;Miya\&quot; \&quot;Javon\&quot; \&quot;Delilah\&quot; \&quot;Jaiden\&quot;]&quot;, :offset 184, :ns &quot;core.core&quot;} {:command &quot;(count[\&quot;Brayan\&quot; \&quot;August\&quot; \&quot;Brianna\&quot; \&quot;Mya\&quot; \&quot;Salma\&quot; \&quot;Barrett\&quot; \&quot;Mallory\&quot; \&quot;Jazlynn\&quot; \&quot;Julius\&quot; \&quot;Aliya\&quot;\n \&quot;Katelyn\&quot; \&quot;Dereon\&quot; \&quot;Courtney\&quot; \&quot;Christian\&quot; \&quot;Charity\&quot; \&quot;Erica\&quot; \&quot;Miya\&quot; \&quot;Javon\&quot; \&quot;Delilah\&quot; \&quot;Jaiden\&quot;])\n[\&quot;Rice\&quot; \&quot;Dandelions\&quot; \&quot;Ivy\&quot; \&quot;Birch\&quot; \&quot;Apple\&quot; \&quot;Poppy\&quot; \&quot;Chamomile\&quot; \&quot;Strawberry\&quot;]\n(count\&quot;CPSIDRAISAARPPDCICDSPBCSSARCSSSDDAIISRCRPCPRSDPPRDCSSACRCBCCCCBSBBBPCISSPDDPPIAIADBPPSPAASSACIRDPADS\&quot;)&quot;, :offset 276, :ns &quot;core.core&quot;} {:command &quot;(count\&quot;IBIRDSPBIBRBPISBPBICCIPDPRIBABICAPSICSDPRRBARDBRPRBADRBBPBCR\n                  ACBSRIAPBIRPIRBBCPSDSAIRRIPDDBSCIIBAACSAASIDBBDISRBCPAABARCR\&quot;)&quot;, :offset 6, :ns &quot;core.core&quot;} {:command &quot;(count\&quot;IBIRRDSPBIBRBPISBPBICCIPDPRIBABICAPSICSDPRRBARDBRPRBADRBBPBCR\n                  ACBSRIAPBIRPIRBBCPSDSAIRRIPDDBSCIIBAACSAASIDBBDISRBCPAABARCR\&quot;)&quot;, :offset 11, :ns &quot;core.core&quot;} {:command &quot;(count\&quot;IBIRRDSPBIBRBPISBPBICCIPDPRIBABICAPSICSDPRRBARDBRPRBADRBBPBCRACBSRIAPBIRPIRBBCPSDSAIRRIPDDBSCIIBAACSAASIDBBDISRBCPAABARCR\&quot;)&quot;, :offset 68, :ns &quot;core.core&quot;} {:command &quot;(count \&quot;IBIRRDSPBIBRBPISBPBICCIPDPRIBABICAPSICSDPRRBARDBRPRBADRBBPBCRACBSRIAPBIRPIRBBCPSDSAIRRIPDDBSCIIBAACSAASIDBBDISRBCPAABARCR\&quot;)&quot;, :offset 131, :ns &quot;core.core&quot;} {:command &quot;(kindergardeners [\&quot;Brayan\&quot; \&quot;August\&quot; \&quot;Brianna\&quot; \&quot;Mya\&quot; \&quot;Salma\&quot; \&quot;Barrett\&quot; \&quot;Mallory\&quot; \&quot;Jazlynn\&quot; \&quot;Julius\&quot; \&quot;Aliya\&quot;\n                  \&quot;Katelyn\&quot; \&quot;Dereon\&quot; \&quot;Courtney\&quot; \&quot;Christian\&quot; \&quot;Charity\&quot; \&quot;Erica\&quot; \&quot;Miya\&quot; \&quot;Javon\&quot; \&quot;Delilah\&quot; \&quot;Jaiden\&quot;]\n                 [\&quot;Rice\&quot; \&quot;Dandelions\&quot; \&quot;Ivy\&quot; \&quot;Birch\&quot; \&quot;Apple\&quot; \&quot;Poppy\&quot; \&quot;Chamomile\&quot; \&quot;Strawberry\&quot;]\n                 \&quot;IBIRDSPBIBRBPISBPBICCIPDPRIBABICAPSICSDPRRBARDBRPRBADRBBPBCRACBSRIAPBIRPIRBBCPSDSAIRRIPDDBSCIIBAACSAASIDBBDISRBCPAABARCR\&quot;\n                 3 2)&quot;, :offset 0, :ns &quot;core.core&quot;} {:command &quot;(is (= [\&quot;Chamomile\&quot; \&quot;Strawberry\&quot; \&quot;Chamomile\&quot; \&quot;Poppy\&quot; \&quot;Apple\&quot; \&quot;Rice\&quot;] (:Mya (kindergardeners [\&quot;Brayan\&quot; \&quot;August\&quot; \&quot;Brianna\&quot; \&quot;Mya\&quot; \&quot;Salma\&quot; \&quot;Barrett\&quot; \&quot;Mallory\&quot; \&quot;Jazlynn\&quot; \&quot;Julius\&quot; \&quot;Aliya\&quot;\n                                                                                             \&quot;Katelyn\&quot; \&quot;Dereon\&quot; \&quot;Courtney\&quot; \&quot;Christian\&quot; \&quot;Charity\&quot; \&quot;Erica\&quot; \&quot;Miya\&quot; \&quot;Javon\&quot; \&quot;Delilah\&quot; \&quot;Jaiden\&quot;]\n                                                                                            [\&quot;Rice\&quot; \&quot;Dandelions\&quot; \&quot;Ivy\&quot; \&quot;Birch\&quot; \&quot;Apple\&quot; \&quot;Poppy\&quot; \&quot;Chamomile\&quot; \&quot;Strawberry\&quot;]\n                                                                                            \&quot;IBIRDSPBIBRBPISBPBICCIPDPRIBABICAPSICSDPRRBARDBRPRBADRBBPBCRACBSRIAPBIRPIRBBCPSDSAIRRIPDDBSCIIBAACSAASIDBBDISRBCPAABARCR\&quot;\n                                                                                            3 2))))&quot;, :offset 853, :ns &quot;core.core&quot;} {:command &quot;\n(is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (kindergardeners children plants shelfs 0 2)))&quot;, :offset 104, :ns &quot;core.core&quot;} {:command &quot;(kindergardeners children plants \&quot;VICGVVRVCGGICFVRGCVCFCGVVRCCCGCRIGVFGCRVVCVFCGCV\&quot; 2 2)&quot;, :offset 88, :ns &quot;core.core&quot;} {:command &quot;(is (= [\&quot;Violets\&quot; nil \&quot;Violets\&quot; \&quot;Radishes\&quot;] (:Alice (kindergardeners children plants \&quot;VICGVVRVCGGICFVRGCVCFCGVVRCCCGCRIGVFGCRVVCVFCGCV\&quot; 2 2))))&quot;, :offset 143, :ns &quot;core.core&quot;} {:command &quot;(kindergardeners children [] shelfs 2 2)&quot;, :offset 40, :ns &quot;core.core&quot;} {:command &quot;(kindergardeners [] plants shelfs 2 2)&quot;, :offset 18, :ns &quot;core.core&quot;} {:command &quot;(kindergardeners children plants [] 2 2)&quot;, :offset 34, :ns &quot;core.core&quot;} {:command &quot;(deftest kindergardeners-test\n  (testing \&quot;Kindergardeners\&quot;\n    (testing \&quot;with valid data\&quot;\n      ;Gives answers according to the question\n      (is (= [\&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Violets\&quot; \&quot;Radishes\&quot;] (:Alice (kindergardeners children plants shelfs 2 2))))\n      (is (= [\&quot;Clover\&quot; \&quot;Grass\&quot; \&quot;Clover\&quot; \&quot;Clover\&quot;] (:Bob (kindergardeners children plants shelfs 2 2))))\n      ;If changes the cups per row to 4 and shelfs to 1 then people get sequential sets of 4 plants\n      (is (= [\&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Clover\&quot; \&quot;Grass\&quot;] (:Alice (kindergardeners children plants shelfs 1 4))))\n      (is (= [\&quot;Violets\&quot; \&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Violets\&quot;] (:Bob (kindergardeners children plants shelfs 1 4))))\n      ;Different plants and children\n      (is (= [\&quot;Chamomile\&quot; \&quot;Strawberry\&quot; \&quot;Chamomile\&quot; \&quot;Poppy\&quot; \&quot;Apple\&quot; \&quot;Rice\&quot;] (:Mya (kindergardeners [\&quot;Brayan\&quot; \&quot;August\&quot; \&quot;Brianna\&quot; \&quot;Mya\&quot; \&quot;Salma\&quot; \&quot;Barrett\&quot; \&quot;Mallory\&quot; \&quot;Jazlynn\&quot; \&quot;Julius\&quot; \&quot;Aliya\&quot;\n                                                                                                   \&quot;Katelyn\&quot; \&quot;Dereon\&quot; \&quot;Courtney\&quot; \&quot;Christian\&quot; \&quot;Charity\&quot; \&quot;Erica\&quot; \&quot;Miya\&quot; \&quot;Javon\&quot; \&quot;Delilah\&quot; \&quot;Jaiden\&quot;]\n                                                                                                  [\&quot;Rice\&quot; \&quot;Dandelions\&quot; \&quot;Ivy\&quot; \&quot;Birch\&quot; \&quot;Apple\&quot; \&quot;Poppy\&quot; \&quot;Chamomile\&quot; \&quot;Strawberry\&quot;]\n                                                                                                  \&quot;IBIRDSPBIBRBPISBPBICCIPDPRIBABICAPSICSDPRRBARDBRPRBADRBBPBCRACBSRIAPBIRPIRBBCPSDSAIRRIPDDBSCIIBAACSAASIDBBDISRBCPAABARCR\&quot;\n                                                                                                  3 2)))))\n    (testing \&quot;alternative scenarios\&quot;\n      ;Two of the same name will only count last instance of the name\n      (is (= [\&quot;Clover\&quot; \&quot;Grass\&quot; \&quot;Clover\&quot; \&quot;Clover\&quot;] (:Alice (kindergardeners [\&quot;Alice\&quot; \&quot;Alice\&quot; \&quot;Bob\&quot; \&quot;Charlie\&quot; \&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n                                                                            \&quot;Harriet\&quot; \&quot;Ileana\&quot; \&quot;Joseph\&quot; \&quot;Kincaid\&quot;] plants shelfs 2 2))))\n      ;Names in wrong order\n      (is (= [\&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Violets\&quot; \&quot;Radishes\&quot;] (:Alice (kindergardeners [\&quot;Joseph\&quot; \&quot;Kincaid\&quot; \&quot;Larry\&quot;\&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n                                                                                   \&quot;Harriet\&quot; \&quot;Ileana\&quot;\&quot;Charlie\&quot; \&quot;Alice\&quot; \&quot;Bob\&quot;] plants shelfs 2 2))))\n      ;Different upper case and lower case shelfs, plants and names\n      ;Use unsorted and randomly captilised names\n      (is (= [\&quot;Violets\&quot; \&quot;Clover\&quot; \&quot;Violets\&quot; \&quot;Grass\&quot;] (:Joseph (kindergardeners [\&quot;joseph\&quot; \&quot;Kincaid\&quot; \&quot;Larry\&quot; \&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n                                                                               \&quot;Harriet\&quot; \&quot;Ileana\&quot; \&quot;charlie\&quot; \&quot;Alice\&quot; \&quot;bob\&quot;] plants shelfs 2 2))))\n      ;Randomly captilised list of childrens plants should be same as all capitilised list of plants\n      (is (= (kindergardeners children plants \&quot;vrcGvvrvCGGccgvRgcVcgCGVvrcccGcRrGvcGCRvVcVgcgCV\&quot; 2 2) (kindergardeners children plants shelfs 2 2)))\n      ;Still gives names for plant even if non capitlised\n      (is (= [\&quot;Violets\&quot; \&quot;Clover\&quot; \&quot;Violets\&quot; \&quot;grass\&quot;] (:Joseph (kindergardeners children [\&quot;Violets\&quot; \&quot;grass\&quot; \&quot;Clover\&quot; \&quot;radishes\&quot;] shelfs 2 2)))))\n    (testing \&quot;with invalid or potentially breaking data\&quot;\n      ;No shelfs\n      (is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (kindergardeners children plants shelfs 0 2)))\n      ;Shelf includes plants not in the list gives nil values\n      (is (= [\&quot;Violets\&quot; nil \&quot;Violets\&quot; \&quot;Radishes\&quot;] (:Alice (kindergardeners children plants \&quot;VICGVVRVCGGICFVRGCVCFCGVVRCCCGCRIGVFGCRVVCVFCGCV\&quot; 2 2))))\n      ;No plants means everyone has a collection of nils\n      (is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (:Alice (kindergardeners children [] shelfs 2 2))))\n      ;No children/shelf of plants means the program will exit early\n      (is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (kindergardeners children plants [] 2 2)))\n      (is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (kindergardeners [] plants shelfs 2 2))))))&quot;, :offset 4008, :ns &quot;core.core&quot;} {:command &quot;\n(deftest kindergardeners-test\n  (testing \&quot;Kindergardeners\&quot;\n    (testing \&quot;with valid data\&quot;\n      ;Gives answers according to the question\n      (is (= [\&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Violets\&quot; \&quot;Radishes\&quot;] (:Alice (kindergardeners children plants shelfs 2 2))))\n      (is (= [\&quot;Clover\&quot; \&quot;Grass\&quot; \&quot;Clover\&quot; \&quot;Clover\&quot;] (:Bob (kindergardeners children plants shelfs 2 2))))\n      ;If changes the cups per row to 4 and shelfs to 1 then people get sequential sets of 4 plants\n      (is (= [\&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Clover\&quot; \&quot;Grass\&quot;] (:Alice (kindergardeners children plants shelfs 1 4))))\n      (is (= [\&quot;Violets\&quot; \&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Violets\&quot;] (:Bob (kindergardeners children plants shelfs 1 4))))\n      ;Different plants and children\n      (is (= [\&quot;Chamomile\&quot; \&quot;Strawberry\&quot; \&quot;Chamomile\&quot; \&quot;Poppy\&quot; \&quot;Apple\&quot; \&quot;Rice\&quot;] (:Mya (kindergardeners [\&quot;Brayan\&quot; \&quot;August\&quot; \&quot;Brianna\&quot; \&quot;Mya\&quot; \&quot;Salma\&quot; \&quot;Barrett\&quot; \&quot;Mallory\&quot; \&quot;Jazlynn\&quot; \&quot;Julius\&quot; \&quot;Aliya\&quot;\n                                                                                                   \&quot;Katelyn\&quot; \&quot;Dereon\&quot; \&quot;Courtney\&quot; \&quot;Christian\&quot; \&quot;Charity\&quot; \&quot;Erica\&quot; \&quot;Miya\&quot; \&quot;Javon\&quot; \&quot;Delilah\&quot; \&quot;Jaiden\&quot;]\n                                                                                                  [\&quot;Rice\&quot; \&quot;Dandelions\&quot; \&quot;Ivy\&quot; \&quot;Birch\&quot; \&quot;Apple\&quot; \&quot;Poppy\&quot; \&quot;Chamomile\&quot; \&quot;Strawberry\&quot;]\n                                                                                                  \&quot;IBIRDSPBIBRBPISBPBICCIPDPRIBABICAPSICSDPRRBARDBRPRBADRBBPBCRACBSRIAPBIRPIRBBCPSDSAIRRIPDDBSCIIBAACSAASIDBBDISRBCPAABARCR\&quot;\n                                                                                                  3 2)))))\n    (testing \&quot;alternative scenarios\&quot;\n      ;Two of the same name will only count last instance of the name\n      (is (= [\&quot;Clover\&quot; \&quot;Grass\&quot; \&quot;Clover\&quot; \&quot;Clover\&quot;] (:Alice (kindergardeners [\&quot;Alice\&quot; \&quot;Alice\&quot; \&quot;Bob\&quot; \&quot;Charlie\&quot; \&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n                                                                            \&quot;Harriet\&quot; \&quot;Ileana\&quot; \&quot;Joseph\&quot; \&quot;Kincaid\&quot;] plants shelfs 2 2))))\n      ;Names in wrong order\n      (is (= [\&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Violets\&quot; \&quot;Radishes\&quot;] (:Alice (kindergardeners [\&quot;Joseph\&quot; \&quot;Kincaid\&quot; \&quot;Larry\&quot;\&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n                                                                                   \&quot;Harriet\&quot; \&quot;Ileana\&quot;\&quot;Charlie\&quot; \&quot;Alice\&quot; \&quot;Bob\&quot;] plants shelfs 2 2))))\n      ;Different upper case and lower case shelfs, plants and names\n      ;Use unsorted and randomly captilised names\n      (is (= [\&quot;Violets\&quot; \&quot;Clover\&quot; \&quot;Violets\&quot; \&quot;Grass\&quot;] (:Joseph (kindergardeners [\&quot;joseph\&quot; \&quot;Kincaid\&quot; \&quot;Larry\&quot; \&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n                                                                               \&quot;Harriet\&quot; \&quot;Ileana\&quot; \&quot;charlie\&quot; \&quot;Alice\&quot; \&quot;bob\&quot;] plants shelfs 2 2))))\n      ;Randomly captilised list of childrens plants should be same as all capitilised list of plants\n      (is (= (kindergardeners children plants \&quot;vrcGvvrvCGGccgvRgcVcgCGVvrcccGcRrGvcGCRvVcVgcgCV\&quot; 2 2) (kindergardeners children plants shelfs 2 2)))\n      ;Still gives names for plant even if non capitlised\n      (is (= [\&quot;Violets\&quot; \&quot;Clover\&quot; \&quot;Violets\&quot; \&quot;grass\&quot;] (:Joseph (kindergardeners children [\&quot;Violets\&quot; \&quot;grass\&quot; \&quot;Clover\&quot; \&quot;radishes\&quot;] shelfs 2 2)))))\n    (testing \&quot;with invalid or potentially breaking data\&quot;\n      ;No shelfs\n      (is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (kindergardeners children plants shelfs 0 2)))\n      ;Shelf includes plants not in the list gives nil values\n      (is (= [\&quot;Violets\&quot; nil \&quot;Violets\&quot; \&quot;Radishes\&quot;] (:Alice (kindergardeners children plants \&quot;VICGVVRVCGGICFVRGCVCFCGVVRCCCGCRIGVFGCRVVCVFCGCV\&quot; 2 2))))\n      ;No plants means everyone has a collection of nils\n      (is (= [nil nil nil nil] (:Alice (kindergardeners children [] shelfs 2 2))))\n      ;No children/shelf of plants means the program will exit early\n      (is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (kindergardeners children plants [] 2 2)))\n      (is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (kindergardeners [] plants shelfs 2 2))))))\n&quot;, :offset 3973, :ns &quot;core.core&quot;} {:command &quot;(kindergardeners-test)&quot;, :offset 21, :ns &quot;core.core&quot;} {:command &quot;(ns core.core\n  (:require [clojure.test :refer :all])\n  (:require [clojure.data.json :as json])\n  (:require [clojure.string :as str]))\n(use 'clojure.test)&quot;, :offset 154, :ns &quot;core.core&quot;} {:command &quot;;Used to keyword data that may have brackets or spaces that cause them to not keyword properly\n(defn keywordify [string]\n  (keyword(str/replace string #\&quot;[\\)\\(\\s\\,\\'\\n\\/\\:\\@']\&quot; \&quot;\&quot;)))\n\n;Reads the JSON file and handles dates\n(defn my-value-reader [key value]\n  (if (= key :date)\n    (java.sql.Date/valueOf value)\n    value))\n\n;user can enter the URL or full collection into each function for flexibility\n(defn define-data [info]\n  (cond\n    (string? info) (json/read-str (slurp info)\n                                  :value-fn my-value-reader\n                                  :key-fn keyword)\n    (coll? info) info))\n(def info (json/read-str\n            (slurp \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)\n            :value-fn my-value-reader\n            :key-fn keyword))\n;Used to parse the dates that are given in the NASA JSON file\n(defn parse-date-year [x]\n  (.format\n    (java.text.SimpleDateFormat. \&quot;yyyy\&quot;)\n    (.parse\n      (java.text.SimpleDateFormat. \&quot;yyyy-MM-DD\&quot;) x)))\n(defn frequencies-by-key [key data]\n  (frequencies (for [x data]\n                 (if (contains? x key)\n                   (x key)))))&quot;, :offset 1117, :ns &quot;core.core&quot;} {:command &quot;(defn most-falls-year [data]\n  (def d (define-data data))\n  (-&gt;&gt;\n    (reduce (fn [m [d v]]\n              (if (some? d)\n                (assoc m (parse-date-year d) v)))\n            {} (frequencies-by-key :year d))\n    (sort-by val)\n    last))\n(most-falls-year info)&quot;, :offset 265, :ns &quot;core.core&quot;} {:command &quot;(frequencies-by-key :year d)&quot;, :offset 28, :ns &quot;core.core&quot;} {:command &quot;(defn most-falls-year [data]\n  (def d (define-data data))\n  (-&gt;&gt;\n    (reduce (fn [m [d v]]\n              (if (some? d)\n                (assoc m d v)))\n            {}\n            (frequencies-by-key :year (parse-date-year d))) ;Gets the\n    (sort-by val)\n    last))\n(most-falls-year info)&quot;, :offset 287, :ns &quot;core.core&quot;} {:command &quot;(defn most-falls-year [data]\n  (def d (define-data data))\n  (-&gt;&gt;\n    (reduce (fn [m [d v]]\n              (if (some? d)\n                (assoc m (parse-date-year d) v)))\n            {}\n            (frequencies-by-key :year d)) ;Gets the \n    (sort-by val)\n    last))\n(most-falls-year info)&quot;, :offset 288, :ns &quot;core.core&quot;} {:command &quot;(deftest Q4-1-test\n  (testing \&quot;Question 4 Which year saw the most individual meteor falls?\&quot;\n    (is (=[\&quot;1933\&quot; 16]\n          (most-falls-year info)))))&quot;, :offset 150, :ns &quot;core.core&quot;} {:command &quot;(Q4-1-test)&quot;, :offset 10, :ns &quot;core.core&quot;} {:command &quot;(deftest Q4-1-test\n  (testing \&quot;Question 4 Which year saw the most individual meteor falls?\&quot;\n    (is (=[\&quot;1933\&quot; 16]\n          (most-falls-year info)))\n    (is (=[\&quot;1933\&quot; 16]\n          (most-falls-year \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)))))&quot;, :offset 250, :ns &quot;core.core&quot;} {:command &quot;(defn heaviest-collective-fall [data]\n  (def d (define-data data))\n  (-&gt;&gt;\n    (apply merge-with (comp +)\n           (for [x d]\n             (if (and (contains? x :mass)(contains? x :year))\n               {(keyword (parse-date-year (x :year)))\n                (Float/parseFloat (x :mass))})))\n    (sort-by val)\n    last\n    ))\n(heaviest-collective-fall info)&quot;, :offset 357, :ns &quot;core.core&quot;} {:command &quot;(deftest Q4-2-test\n  (testing \&quot;Question 4-2. Which year saw the heaviest collective meteor fall?\&quot;\n    ;Test using the previously downloaded data\n    (is (=[:1947 2.303023E7]\n          (most-falls-year info)))\n    ;Test using the URL\n    (is (=[:1947 2.303023E7]\n          (most-falls-year \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)))))&quot;, :offset 341, :ns &quot;core.core&quot;} {:command &quot;\n(deftest Q4-2-test\n  (testing \&quot;Question 4-2. Which year saw the heaviest collective meteor fall?\&quot;\n    ;Test using the previously downloaded data\n    (is (=[:1947 2.303023E7]\n          (heaviest-collective-fall info)))\n    ;Test using the URL\n    (is (=[:1947 2.303023E7]\n          (heaviest-collective-fall \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)))))&quot;, :offset 360, :ns &quot;core.core&quot;} {:command &quot;(defn heaviest-type [data]\n  (def meteorites (filter some? (map\n                                  #(if (and (contains? % :recclass)(contains? % :mass))\n                                     {(keyword(keywordify (% :recclass)))\n                                      (Float/parseFloat (% :mass))})data)))\n  (def meteorites-freq (frequencies(map\n                                     #(if (and (contains? % :recclass)(contains? % :mass))\n                                        (keyword(keywordify (% :recclass)))) data)))\n  (-&gt;&gt;\n    (reduce\n      (fn [m [k v]] (assoc m k (/ v (meteorites-freq k))))\n      {} (apply merge-with (comp +) meteorites))\n    (sort-by val)\n    last)\n  )\n(heaviest-type info)&quot;, :offset 697, :ns &quot;core.core&quot;} {:command &quot;(defn heaviest-type [data]\n  (def d (define-data data))\n  (def meteorites (filter some? (map\n                                  #(if (and (contains? % :recclass)(contains? % :mass))\n                                     {(keyword(keywordify (% :recclass)))\n                                      (Float/parseFloat (% :mass))})d)))\n  (def meteorites-freq (frequencies(map\n                                     #(if (and (contains? % :recclass)(contains? % :mass))\n                                        (keyword(keywordify (% :recclass)))) d)))\n  (-&gt;&gt;\n    (reduce\n      (fn [m [k v]] (assoc m k (/ v (meteorites-freq k))))\n      {} (apply merge-with (comp +) meteorites))\n    (sort-by val)\n    last)\n  )\n(heaviest-type info)&quot;, :offset 720, :ns &quot;core.core&quot;} {:command &quot;(heaviest-type \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)&quot;, :offset 63, :ns &quot;core.core&quot;} {:command &quot;\n(deftest Q4-3-test\n  (testing \&quot;Question 4-3. Which type of meteor is the heaviest on average?\&quot;\n    ;Test using the previously downloaded data\n    (is (=[:IronIIAB 3885195.3333333335]\n          (heaviest-type info)))\n    ;Test using the URL\n    (is (=[:IronIIAB 3885195.3333333335]\n          (heaviest-type \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)))))&quot;, :offset 359, :ns &quot;core.core&quot;} {:command &quot;(for [x info]\n  (if (and (contains? x :mass)(contains? x :year))\n    {(keyword (parse-date-year (x :year)))\n     (Float/parseFloat (x :mass))}))&quot;, :offset 12, :ns &quot;core.core&quot;} {:command &quot;meteorites&quot;, :offset 10, :ns &quot;core.core&quot;} {:command &quot;(defn meteorite-range [data]\n  (def years (filter some? (map\n                             #(if (and (contains? % :year))\n                                (Integer/parseInt(parse-date-year (% :year))))data)))\n  (- (apply max years) (apply min years)))\n(meteorite-range info)\n&quot;, :offset 273, :ns &quot;core.core&quot;} {:command &quot;years&quot;, :offset 5, :ns &quot;core.core&quot;} {:command &quot;(defn meteorite-range [data]\n  (def d (define-data data))\n  ;Get all the years in the JSON dataset\n  (def years (filter some? (map\n                             #(if (and (contains? % :year))\n                                (Integer/parseInt(parse-date-year (% :year))))d)))\n  (- (apply max years) (apply min years))) ;Using the max and min year we can find out the range of the dataset\n(meteorite-range info)&quot;, :offset 408, :ns &quot;core.core&quot;} {:command &quot;(deftest Q4-5-test\n  (testing \&quot;Question 4-5. Find how many years between the first and latest meteorite\&quot;\n    ;Test using the previously downloaded data\n    (is (= 1152\n           (meteorite-range info)))\n    ;Test using the URL\n    (is (= 1152\n           (meteorite-range \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)))))&quot;, :offset 324, :ns &quot;core.core&quot;} {:command &quot;(defn distance-two-points [[x1 y1] [x2 y2]]\n  (let [dx (- x2 x1), dy (- y2 y1)]\n    (Math/sqrt (+ (* dx dx) (* dy dy)))))\n(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;))\n                                               ((% :geolocation):coordinates)})\n                                           data))))\n  (loop [i 0 j 1 dist 10000000]\n    (println i j dist)\n    (if (= i (dec (count vec-co-ords)))\n      dist\n      (let [new-dist (min dist (distance-two-points\n                                 (val(first(nth vec-co-ords i)))\n                                 (val(first(nth vec-co-ords j)))))]\n        (if (= j (dec (count vec-co-ords)))\n          (recur (inc i) (-&gt; i inc inc) new-dist)\n          (recur i (inc j) new-dist))))))\n(closest-pair info)&quot;, :offset 1105, :ns &quot;core.core&quot;} {:command &quot;(= 0.0 0\n   )&quot;, :offset 12, :ns &quot;core.core&quot;} {:command &quot;(time (closest-pair info))\n&quot;, :offset 27, :ns &quot;core.core&quot;} {:command &quot;(defn distance-two-points [[x1 y1] [x2 y2]] ;Use pythagoras to find distance between two points\n  (let [dx (- x2 x1), dy (- y2 y1)]\n    (+ (* dx dx) (* dy dy))))\n(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;))\n                                               ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist 10000000]\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min dist (distance-two-points\n                                            (val(first(nth vec-co-ords i)))\n                                            (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))&quot;, :offset 1229, :ns &quot;core.core&quot;} {:command &quot;(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keywordify (% name))\n                                               ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist 100000000]\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min dist (distance-two-points\n                                            (val(first(nth vec-co-ords i)))\n                                            (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))&quot;, :offset 1032, :ns &quot;core.core&quot;} {:command &quot;(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keywordify (% name)) ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist 100000000]\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min dist (distance-two-points\n                                            (val(first(nth vec-co-ords i)))\n                                            (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))&quot;, :offset 985, :ns &quot;core.core&quot;} {:command &quot;(defn heaviest-type [data]\n  (def d (define-data data))\n  ;Gets a collection of meteorite entry with the class as the key and the mass as the value\n  (def meteorites (filter some? (map\n                                  #(if (and (contains? % :recclass)(contains? % :mass))\n                                     {(keywordify (% :recclass))\n                                      (Float/parseFloat (% :mass))})d)))\n  ;Gets a collection each meteorite class and how many of each there are\n  (def meteorites-freq (frequencies(map\n                                     #(if (and (contains? % :recclass)(contains? % :mass))\n                                        (keywordify (% :recclass))) d)))\n  (-&gt;&gt;\n    (reduce\n      (fn [m [k v]] (assoc m k (/ v (meteorites-freq k))))  ;divide each collective weight of meteor by how many times it occurs to get average\n      {} (apply merge-with (comp +) meteorites)) ;get collective weight of each meteor class using comp and merge-with\n    (sort-by val)\n    last)\n  )\n(heaviest-type info)&quot;, :offset 1022, :ns &quot;core.core&quot;} {:command &quot;(str \&quot;poop\&quot; \&quot;-\&quot; \&quot;thing\&quot;)&quot;, :offset 14, :ns &quot;core.core&quot;} {:command &quot;(keyword (str(name (key (nth vec-co-ords 32))) \&quot;\&quot; (name (key (nth vec-co-ords 54)))))&quot;, :offset 48, :ns &quot;core.core&quot;} {:command &quot;(name(key (nth vec-co-ords 32)))&quot;, :offset 32, :ns &quot;core.core&quot;} {:command &quot;(key (nth vec-co-ords 32))&quot;, :offset 26, :ns &quot;core.core&quot;} {:command &quot;vec-co-ords&quot;, :offset 11, :ns &quot;core.core&quot;} {:command &quot;(name(key (first (nth vec-co-ords 32))))&quot;, :offset 40, :ns &quot;core.core&quot;} {:command &quot;(keyword (str(name(key (first (nth vec-co-ords 32))))\n             \&quot;-\&quot;\n             (name(key (first (nth vec-co-ords 54))))))&quot;, :offset 69, :ns &quot;core.core&quot;} {:command &quot;{(keyword (str(name(key (first (nth vec-co-ords 43))))\n              \&quot;-\&quot;\n              (name(key (first (nth vec-co-ords 22))))))\n 1000}&quot;, :offset 123, :ns &quot;core.core&quot;} {:command &quot;(defn distance-two-points [[x1 y1] [x2 y2]] ;Use pythagoras to find distance between two points\n  (let [dx (- x2 x1), dy (- y2 y1)]\n    (+ (* dx dx) (* dy dy))))\n(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;)) ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist 100000000]\n               (println dist)\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min (val (first dist)) (distance-two-points\n                                                          (val(first(nth vec-co-ords i)))\n                                                          (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) {(keyword (str(name(key (first (nth vec-co-ords i))))\n                                                                 \&quot;-\&quot;\n                                                                 (name(key (first (nth vec-co-ords j))))))\n                                                    new-dist})\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))&quot;, :offset 1538, :ns &quot;core.core&quot;} {:command &quot;(defn distance-two-points [[x1 y1] [x2 y2]] ;Use pythagoras to find distance between two points\n  (let [dx (- x2 x1), dy (- y2 y1)]\n    (+ (* dx dx) (* dy dy))))\n(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;)) ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist {:key 100000000}]\n               (println dist)\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min (val (first dist)) (distance-two-points\n                                                          (val(first(nth vec-co-ords i)))\n                                                          (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) {(keyword (str(name(key (first (nth vec-co-ords i))))\n                                                                 \&quot;-\&quot;\n                                                                 (name(key (first (nth vec-co-ords j))))))\n                                                    new-dist})\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))&quot;, :offset 1545, :ns &quot;core.core&quot;} {:command &quot;{(keyword (str(name(key (first (nth vec-co-ords i))))\n              \&quot;-\&quot;\n              (name(key (first (nth vec-co-ords j))))))\n 1000}&quot;, :offset 133, :ns &quot;core.core&quot;} {:command &quot;(val (first {(keyword (str(name(key (first (nth vec-co-ords 43))))\n                          \&quot;-\&quot;\n                          (name(key (first (nth vec-co-ords 22))))))\n             1000})) &quot;, :offset 184, :ns &quot;core.core&quot;} {:command &quot;{(keyword (str(name(key (first (nth vec-co-ords 43))))\n              \&quot;-\&quot;\n              (name(key (first (nth vec-co-ords 22))))))\n 1000}{(keyword (str(name(key (first (nth vec-co-ords 43))))\n                    \&quot;-\&quot;\n                    (name(key (first (nth vec-co-ords 22))))))\n       1000}&quot;, :offset 290, :ns &quot;core.core&quot;} {:command &quot;{(keyword (str(name(key (first (nth vec-co-ords 33))))\n              \&quot;-\&quot;\n              (name(key (first (nth vec-co-ords 22))))))\n 1000}{(keyword (str(name(key (first (nth vec-co-ords 43))))\n                    \&quot;-\&quot;\n                    (name(key (first (nth vec-co-ords 22))))))\n       1000}&quot;, :offset 290, :ns &quot;core.core&quot;} {:command &quot;{(keyword (str(name(key (first (nth vec-co-ords 33))))\n              \&quot;-\&quot;\n              (name(key (first (nth vec-co-ords 22))))))\n 1000}{(keyword (str(name(key (first (nth vec-co-ords 43))))\n                    \&quot;-\&quot;\n                    (name(key (first (nth vec-co-ords 22))))))\n       100}&quot;, :offset 288, :ns &quot;core.core&quot;} {:command &quot;(min{(keyword (str(name(key (first (nth vec-co-ords 33))))\n              \&quot;-\&quot;\n              (name(key (first (nth vec-co-ords 22))))))\n 1000}{(keyword (str(name(key (first (nth vec-co-ords 43))))\n                    \&quot;-\&quot;\n                    (name(key (first (nth vec-co-ords 22))))))\n       100})&quot;, :offset 4, :ns &quot;core.core&quot;} {:command &quot;(min\n  (first{(keyword (str(name(key (first (nth vec-co-ords 33))))\n              \&quot;-\&quot;\n              (name(key (first (nth vec-co-ords 22))))))\n 1000})\n  (first{(keyword (str(name(key (first (nth vec-co-ords 43))))\n                    \&quot;-\&quot;\n                    (name(key (first (nth vec-co-ords 22))))))\n       100}))&quot;, :offset 159, :ns &quot;core.core&quot;} {:command &quot;(min-key\n  (first{(keyword (str(name(key (first (nth vec-co-ords 33))))\n              \&quot;-\&quot;\n              (name(key (first (nth vec-co-ords 22))))))\n 1000})\n  (first{(keyword (str(name(key (first (nth vec-co-ords 43))))\n                    \&quot;-\&quot;\n                    (name(key (first (nth vec-co-ords 22))))))\n       100}))&quot;, :offset 8, :ns &quot;core.core&quot;} {:command &quot;(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;)) ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist {:key 100000000}]\n               (println dist)\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min-key dist {(keyword (str(name(key (first (nth vec-co-ords i))))\n                                                            \&quot;-\&quot;\n                                                            (name(key (first (nth vec-co-ords j))))))\n                                               (distance-two-points\n                                                 (val(first(nth vec-co-ords i)))\n                                                 (val(first(nth vec-co-ords j))))})]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))&quot;, :offset 1340, :ns &quot;core.core&quot;} {:command &quot;(ns core.core\n  (:require [clojure.test :refer :all])\n  (:require [clojure.data.json :as json])\n  (:require [clojure.string :as str]))\n(use 'clojure.test)\n;Used to keyword data that may have brackets or spaces that cause them to not keyword properly\n(defn keywordify [string]\n  (keyword(str/replace string #\&quot;[\\)\\(\\s\\,\\'\\n\\/\\:\\@']\&quot; \&quot;\&quot;)))\n\n;Reads the JSON file and handles dates\n(defn my-value-reader [key value]\n  (if (= key :date)\n    (java.sql.Date/valueOf value)\n    value))\n\n;user can enter the URL or full collection into each function for flexibility\n(defn define-data [info]\n  (cond\n    (string? info) (json/read-str (slurp info)\n                                  :value-fn my-value-reader\n                                  :key-fn keyword)\n    (coll? info) info))\n(def info (json/read-str\n            (slurp \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)\n            :value-fn my-value-reader\n            :key-fn keyword))\n;Used to parse the dates that are given in the NASA JSON file\n(defn parse-date-year [x]\n  (.format\n    (java.text.SimpleDateFormat. \&quot;yyyy\&quot;)\n    (.parse\n      (java.text.SimpleDateFormat. \&quot;yyyy-MM-DD\&quot;) x)))\n(defn frequencies-by-key [key data]\n  (frequencies (for [x data]\n                 (if (contains? x key)\n                   (x key)))))&quot;, :offset 154, :ns &quot;core.core&quot;} {:command &quot;(let [new-dist (min-key\n                 {:Château-Renard-Sulagiri 6886.249917111201}\n                 {:Château-Renard-Sulagiri 6886.249917111201})])&quot;, :offset 147, :ns &quot;core.core&quot;} {:command &quot;(defn distance-two-points [[x1 y1] [x2 y2]] ;Use pythagoras to find distance between two points\n  (let [dx (- x2 x1), dy (- y2 y1)]\n    (+ (* dx dx) (* dy dy))))\n(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;)) ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist {:key 100000000}]\n               (println dist)\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min-key (first dist) (first {(keyword (str(name(key (first (nth vec-co-ords i)))) \&quot;-\&quot;\n                                                                           (name(key (first (nth vec-co-ords j))))))\n                                                              (distance-two-points\n                                                                (val(first(nth vec-co-ords i)))\n                                                                (val(first(nth vec-co-ords j))))}))]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))&quot;, :offset 1518, :ns &quot;core.core&quot;} {:command &quot;(let [new-dist (min-key\n                 (first{:Château-Renard-Sulagiri 6886.249917111201})\n                 (first{:Château-Renard-Sulagiri 6886.249917111201}))])&quot;, :offset 116, :ns &quot;core.core&quot;} {:command &quot;(let [new-dist (min-key\n                 (first{:Château-Renard-Sulagiri 6886.249917111201})\n                 (first{:BanRongDu-Felix 35727.473399555594}))])&quot;, :offset 157, :ns &quot;core.core&quot;} {:command &quot;(min-key\n  (first{:Château-Renard-Sulagiri 6886.249917111201})\n  (first{:BanRongDu-Felix 35727.473399555594}))&quot;, :offset 110, :ns &quot;core.core&quot;} {:command &quot;(min-key\n  (first{:Château-Renard-Sulagiri 6886.249917111201})\n  (first[:BanRongDu-Felix 35727.473399555594]))&quot;, :offset 110} {:command &quot;(reduce into {} (min-key\n  (first{:Château-Renard-Sulagiri 6886.249917111201})\n  (first{:BanRongDu-Felix 35727.473399555594})))&quot;, :offset 14, :ns &quot;core.core&quot;} {:command &quot;(reduce into {map} (min-key\n  (first{:Château-Renard-Sulagiri 6886.249917111201})\n  (first{:BanRongDu-Felix 35727.473399555594})))&quot;, :offset 17, :ns &quot;core.core&quot;} {:command &quot;(defn distance-two-points [[x1 y1] [x2 y2]] ;Use pythagoras to find distance between two points\n  (let [dx (- x2 x1), dy (- y2 y1)]\n    (+ (* dx dx) (* dy dy))))\n(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;)) ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist {:key 100000000}]\n               (println dist)\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min dist (distance-two-points\n                                            (val(first(nth vec-co-ords i)))\n                                            (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))&quot;, :offset 1220, :ns &quot;core.core&quot;} {:command &quot;\n;4. Which two meteorites are closest together?\n(defn distance-two-points [[x1 y1] [x2 y2]] ;Use pythagoras to find distance between two points\n  (let [dx (- x2 x1), dy (- y2 y1)]\n    (+ (* dx dx) (* dy dy))))\n(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;)) ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist 10000000]\n               (println dist)\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min dist (distance-two-points\n                                            (val(first(nth vec-co-ords i)))\n                                            (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))\n&quot;, :offset 1261, :ns &quot;core.core&quot;} {:command &quot;(defn distance-two-points [[x1 y1] [x2 y2]] ;Use pythagoras to find distance between two points\n  (let [dx (- x2 x1), dy (- y2 y1)]\n    (+ (* dx dx) (* dy dy))))\n(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;)) ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist 10000000]\n               (println i j dist)\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min dist (distance-two-points\n                                            (val(first(nth vec-co-ords i)))\n                                            (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))&quot;, :offset 1216, :ns &quot;core.core&quot;} {:command &quot;(defn distance-two-points [[x1 y1] [x2 y2]] ;Use pythagoras to find distance between two points\n  (let [dx (- x2 x1), dy (- y2 y1)]\n    (+ (* dx dx) (* dy dy))))\n(defn closest-pair [data]\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;)) ((% :geolocation):coordinates)})\n                                           data))))\n  (Math/sqrt (loop [i 0 j 1 dist 100000000]\n               (if (= i (dec (count vec-co-ords)))\n                 dist\n                 (let [new-dist (min dist (distance-two-points\n                                            (val(first(nth vec-co-ords i)))\n                                            (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n(time (closest-pair info))&quot;, :offset 1183, :ns &quot;core.core&quot;} {:command &quot;(defn square-list [n]\n  (lazy-seq\n    (if (not (empty? n))\n      (if (number? (first n))\n        (cons (* (first n)(first n)) (square-list (rest n)))\n        (square-list (rest n))))))&quot;, :offset 184, :ns &quot;core.core&quot;} {:command &quot;\n(use 'clojure.test)&quot;, :offset 20, :ns &quot;core.core&quot;} {:command &quot;(testing \&quot;Square list using map\&quot;\n  (testing \&quot;will return a lazy sequence\&quot;\n    (is true (instance? clojure.lang.LazySeq (square-list [1 2 3 4 5 6 7 8 9]))))\n  (testing \&quot;with all forms of numbers.\&quot;\n    (is (= [1 4 9 16 25 36 49 64 81] (square-list [1 2 3 4 5 6 7 8 9])))\n    ;using decimals, exponents, hexadecimal\n    ;in denary the numbers being squared are [0.525, 300, 15]\n    (is (= [0.275625 90000.0 225] (square-list [0.525 3e2 0xF]))))\n  (testing \&quot;with invalid data\&quot;\n    (is (= [4] (square-list [2 \&quot;r\&quot; (sorted-map) \&quot;forty\&quot;])))\n    (is (= [] (square-list [\&quot;qwerty\&quot; \&quot;m\&quot;])))\n    (is (Thrown? IllegalArgumentException (square-list 4)))))&quot;, :offset 639, :ns &quot;core.core&quot;} {:command &quot;(testing \&quot;Square list using map\&quot;\n  (testing \&quot;will return a lazy sequence\&quot;\n    (is true (instance? clojure.lang.LazySeq (square-list [1 2 3 4 5 6 7 8 9]))))\n  (testing \&quot;with all forms of numbers.\&quot;\n    (is (= [1 4 9 16 25 36 49 64 81] (square-list [1 2 3 4 5 6 7 8 9])))\n    ;using decimals, exponents, hexadecimal\n    ;in denary the numbers being squared are [0.525, 300, 15]\n    (is (= [0.275625 90000.0 225] (square-list [0.525 3e2 0xF]))))\n  (testing \&quot;with invalid data\&quot;\n    (is (= [4] (square-list [2 \&quot;r\&quot; (sorted-map) \&quot;forty\&quot;])))\n    (is (= [] (square-list [\&quot;qwerty\&quot; \&quot;m\&quot;])))\n    (is (thrown? IllegalArgumentException (square-list 4)))))&quot;, :offset 639, :ns &quot;core.core&quot;} {:command &quot;(square-list 4)&quot;, :offset 15, :ns &quot;core.core&quot;} {:command &quot;(is (thrown? IllegalArgumentException (square-list 4)))&quot;, :offset 55, :ns &quot;core.core&quot;} {:command &quot;(defn denomination-count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination-count amount (rest dens))\n             (denomination-count (- amount (first dens)) dens))))\n;Rebind denomination-count to a memoised version for caching\n(def denomination-count (memoize denomination-count))\n(defn dollar-count\n  [amount coins]\n  ;This map function caches each coin amount from 0, 1, 2,....n+1\n  ;This means that each previous amount become memoised and subsequent amounts\n  ;speed up exponentially as all amounts but the current amount have been cached\n  ;I have tried many steps in trying to memoise in steps of 1, 100 and 1000 and have timed each in a new REPL\n  ;Incrementing by 1000 can results in a less stable system and can cause stack overflow errors\n  ;Incrementing by 1 is slightly slower than 10 while 100 is faster than both in large amounts (e.g. 100000 cents)\n  ;On smaller amounts (e.g. 242) it makes sense to keep it incrementing by 1 or at a push 10 as incrementing 100 or 1000\n  ;on 300 for example loses opportunities to optimise (albeit not needed really on smaller amounts)\n  (last (map #(denomination-count % coins) (range (inc amount)))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 10))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 100))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 1000))))\n\n(time(dollar-count 100 [1 5 10 25]))&quot;, :offset 1466, :ns &quot;core.core&quot;} {:command &quot;(is (= 0 (dollar-count 100 [])))\n(is (= 1 (dollar-count 0 [1 5 10 25 50 100])))&quot;, :offset 79, :ns &quot;core.core&quot;} {:command &quot;(defn transform ;gives a key of the starting letter to each item in the list, used to identify plants using initials\n  [coll]\n  (reduce-kv (fn [m k v]\n               (if (empty? v) m\n                              (assoc m (keyword (str/capitalize(str(first v)))) v)))\n             {} coll))&quot;, :offset 290, :ns &quot;core.core&quot;} {:command &quot;(transform                                                                       [\&quot;Rice\&quot; \&quot;Dandelions\&quot; \&quot;Ivy\&quot; \&quot;Birch\&quot; \&quot;Apple\&quot; \&quot;Poppy\&quot; \&quot;Chamomile\&quot; \&quot;Strawberry\&quot;]\n                                                                                 )&quot;, :offset 239, :ns &quot;core.core&quot;} {:command &quot;(transform                                                                       [\&quot;Roo\&quot; \&quot;Rice\&quot; \&quot;Dandelions\&quot; \&quot;Ivy\&quot; \&quot;Birch\&quot; \&quot;Apple\&quot; \&quot;Poppy\&quot; \&quot;Chamomile\&quot; \&quot;Strawberry\&quot;]\n                                                                                 )&quot;, :offset 86, :ns &quot;core.core&quot;} {:command &quot;(testing \&quot;Square list using map\&quot;\n  (testing \&quot;will return a lazy sequence\&quot;\n    (is true (instance? clojure.lang.LazySeq (square-list [1 2 3 4 5 6 7 8 9]))))\n  (testing \&quot;with all forms of numbers.\&quot;\n    (is (= [1 4 9 16 25 36 49 64 81] (square-list [1 2 3 4 5 6 7 8 9])))\n    ;using decimals, exponents, hexadecimal\n    ;in denary the numbers being squared are [0.525, 300, 15]\n    (is (= [0.275625 90000.0 225] (square-list [0.525 3e2 0xF]))))\n  (testing \&quot;with invalid data\&quot;\n    (is (= [4] (square-list [2 \&quot;r\&quot; (sorted-map) \&quot;forty\&quot;])))\n    (is (= [] (square-list [\&quot;qwerty\&quot; \&quot;m\&quot;])))))\n(testing \&quot;Square list using map\&quot;\n  (testing \&quot;will return a lazy sequence\&quot;\n    (is true (instance? clojure.lang.LazySeq (map-square [1 2 3 4 5 6 7 8 9]))))\n  (testing \&quot;with all forms of numbers.\&quot;\n    (is (= [1 4 9 16 25 36 49 64 81] (map-square [1 2 3 4 5 6 7 8 9])))\n    ;using decimals, exponents, hexadecimal\n    ;in denary the numbers being squared are [0.525, 300, 15]\n    (is (= [0.275625 90000.0 225] (map-square [0.525 3e2 0xF]))))\n  (testing \&quot;with invalid data\&quot;\n    (is (= [4] (map-square [2 \&quot;r\&quot; (sorted-map) \&quot;forty\&quot;])))\n    (is (= [] (map-square [\&quot;qwerty\&quot; \&quot;m\&quot;])))))&quot;, :offset 1154, :ns &quot;core.core&quot;} {:command &quot;(defn square-list [n]\n  (lazy-seq\n    (if (not (empty? n))\n      (if (number? (first n))\n        (cons (* (first n)(first n)) (square-list (rest n)))\n        (square-list (rest n))))))\n\n;The map function returns a lazy sequence and are well known in functional programming languages for being powerful\n;The filter function is used to remove non-numerical items\n;Then the map function applies the anonymous function #(* % %) (where % is the current list item) to each item\n;Finally a lazy sequence of the squared list items is returned\n(defn map-square [n]\n  (map #(* % %) (filter number? n)))\n(map-square [1 2 3 4 5 6 7 8 9])\n(testing \&quot;Square list using map\&quot;\n  (testing \&quot;will return a lazy sequence\&quot;\n    (is true (instance? clojure.lang.LazySeq (square-list [1 2 3 4 5 6 7 8 9]))))\n  (testing \&quot;with all forms of numbers.\&quot;\n    (is (= [1 4 9 16 25 36 49 64 81] (square-list [1 2 3 4 5 6 7 8 9])))\n    ;using decimals, exponents, hexadecimal\n    ;in denary the numbers being squared are [0.525, 300, 15]\n    (is (= [0.275625 90000.0 225] (square-list [0.525 3e2 0xF]))))\n  (testing \&quot;with invalid data\&quot;\n    (is (= [4] (square-list [2 \&quot;r\&quot; (sorted-map) \&quot;forty\&quot;])))\n    (is (= [] (square-list [\&quot;qwerty\&quot; \&quot;m\&quot;])))))\n(testing \&quot;Square list using map\&quot;\n  (testing \&quot;will return a lazy sequence\&quot;\n    (is true (instance? clojure.lang.LazySeq (map-square [1 2 3 4 5 6 7 8 9]))))\n  (testing \&quot;with all forms of numbers.\&quot;\n    (is (= [1 4 9 16 25 36 49 64 81] (map-square [1 2 3 4 5 6 7 8 9])))\n    ;using decimals, exponents, hexadecimal\n    ;in denary the numbers being squared are [0.525, 300, 15]\n    (is (= [0.275625 90000.0 225] (map-square [0.525 3e2 0xF]))))\n  (testing \&quot;with invalid data\&quot;\n    (is (= [4] (map-square [2 \&quot;r\&quot; (sorted-map) \&quot;forty\&quot;])))\n    (is (= [] (map-square [\&quot;qwerty\&quot; \&quot;m\&quot;])))))&quot;, :offset 625, :ns &quot;core.core&quot;} {:command &quot;(vec-co-ords 315)&quot;, :offset 16, :ns &quot;core.core&quot;} {:command &quot;(nth vec-co-ords 315)&quot;, :offset 5, :ns &quot;core.core&quot;} {:command &quot;(nth vec-co-ords 313\n     )&quot;, :offset 26, :ns &quot;core.core&quot;} {:command &quot;(ns core.core\n  (:require [clojure.test :refer :all])\n  (:require [clojure.data.json :as json])\n  (:require [clojure.string :as str]))\n(use 'clojure.test)\n;:dependencies [[org.clojure/clojure \&quot;1.10.0\&quot;]\n;                 [org.clojure/data.json \&quot;0.2.7\&quot;]]\n\n;Squaring Lists Sub-task 1\n\n;Explanation\n;There many ways to produce lazy sequences in clojure (e.g. range, take, repeat, iterate, lazy-seq)\n;Here is a not so elegant way of doing it through lazy seq recursively\n(defn square-list [n]\n  (lazy-seq\n    (if (not (empty? n))\n      (if (number? (first n))\n        (cons (* (first n)(first n)) (square-list (rest n)))\n        (square-list (rest n))))))\n\n;The map function returns a lazy sequence and are well known in functional programming languages for being powerful\n;The filter function is used to remove non-numerical items\n;Then the map function applies the anonymous function #(* % %) (where % is the current list item) to each item\n;Finally a lazy sequence of the squared list items is returned\n(defn map-square [n]\n  (map #(* % %) (filter number? n)))\n(map-square [1 2 3 4 5 6 7 8 9])\n\n;Testing section\n(deftest square-list-test\n         (testing \&quot;Square list using map\&quot;\n                  (testing \&quot;will return a lazy sequence\&quot;\n                           (is true (instance? clojure.lang.LazySeq (square-list [1 2 3 4 5 6 7 8 9]))))\n                  (testing \&quot;with all forms of numbers.\&quot;\n                           (is (= [1 4 9 16 25 36 49 64 81] (square-list [1 2 3 4 5 6 7 8 9])))\n                           ;using decimals, exponents, hexadecimal\n                           ;in denary the numbers being squared are [0.525, 300, 15]\n                           (is (= [0.275625 90000.0 225] (square-list [0.525 3e2 0xF]))))\n                  (testing \&quot;with invalid data\&quot;\n                           (is (= [4] (square-list [2 \&quot;r\&quot; (sorted-map) \&quot;forty\&quot;])))\n                           (is (= [] (square-list [\&quot;qwerty\&quot; \&quot;m\&quot;])))))\n         (testing \&quot;Square list using map\&quot;\n                  (testing \&quot;will return a lazy sequence\&quot;\n                           (is true (instance? clojure.lang.LazySeq (map-square [1 2 3 4 5 6 7 8 9]))))\n                  (testing \&quot;with all forms of numbers.\&quot;\n                           (is (= [1 4 9 16 25 36 49 64 81] (map-square [1 2 3 4 5 6 7 8 9])))\n                           ;using decimals, exponents, hexadecimal\n                           ;in denary the numbers being squared are [0.525, 300, 15]\n                           (is (= [0.275625 90000.0 225] (map-square [0.525 3e2 0xF]))))\n                  (testing \&quot;with invalid data\&quot;\n                           (is (= [4] (map-square [2 \&quot;r\&quot; (sorted-map) \&quot;forty\&quot;])))\n                           (is (= [] (map-square [\&quot;qwerty\&quot; \&quot;m\&quot;]))))))\n\n\n;Counting coins Sub-task 2\n\n;To calculate the number of ways to make change for an amount equals\n;Ways to make amount (A) using all but the first kind of coin plus...\n;Ways to change amount A − D (Denominations) using all n kinds of coins\n;Once the amount gets to 0 then a new combination of change is made and\n(defn denomination-count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination-count amount (rest dens))\n             (denomination-count (- amount (first dens)) dens))))\n;Rebind denomination-count to a memoised version for caching\n(def denomination-count (memoize denomination-count))\n(defn dollar-count\n  [amount coins]\n  ;This map function caches each coin amount from 0, 1, 2,....n+1\n  ;This means that each previous amount become memoised and subsequent amounts\n  ;speed up exponentially as all amounts but the current amount have been cached\n  ;I have tried many steps in trying to memoise in steps of 1, 100 and 1000 and have timed each in a new REPL\n  ;Incrementing by 1000 can results in a less stable system and can cause stack overflow errors\n  ;Incrementing by 1 is slightly slower than 10 while 100 is faster than both in large amounts (e.g. 100000 cents)\n  ;On smaller amounts (e.g. 242) it makes sense to keep it incrementing by 1 or at a push 10 as incrementing 100 or 1000\n  ;on 300 for example loses opportunities to optimise (albeit not needed really on smaller amounts)\n  (last (map #(denomination-count % coins) (range (inc amount)))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 10))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 100))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 1000))))\n\n(time(dollar-count 100 [1 5 10 25]))\n(time(dollar-count 100000 [1 5 10 25 50 100]))\n\n(deftest coin-count-test\n         (testing \&quot;Coin count denominations\&quot;\n                  (testing \&quot;with valid data\&quot;\n                           (is (= 242 (dollar-count 100 [1 5 10 25])))\n                           (is (= 13398445413854501 (dollar-count 100000 [1 5 10 25 50 100]))))\n                  (testing \&quot;with valid data\&quot;\n                           (is (= 0 (dollar-count 100 [])))\n                           (is (= 1 (dollar-count 0 [1 5 10 25 50 100]))))))\n\n\n\n;Kindergardeners Sub-task 3\n\n(def children [\&quot;Alice\&quot; \&quot;Bob\&quot; \&quot;Charlie\&quot; \&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n               \&quot;Harriet\&quot; \&quot;Ileana\&quot; \&quot;Joseph\&quot; \&quot;Kincaid\&quot; \&quot;Larry\&quot;])\n(def plants [\&quot;Violets\&quot; \&quot;Grass\&quot; \&quot;Clover\&quot; \&quot;Radishes\&quot;])\n(def shelfs \&quot;VRCGVVRVCGGCCGVRGCVCGCGVVRCCCGCRRGVCGCRVVCVGCGCV\&quot;)\n\n(defn transform ;gives a key of the starting letter to each item in the list, used to identify plants using initials\n  [coll]\n  (reduce-kv (fn [m k v]\n               (if (empty? v) m\n                              (assoc m (keyword (str/capitalize(str(first v)))) v)))\n             {} coll))\n(defn match-plants [children plants shelfs cups-per-row]\n  (def key-plants (transform plants)) ;Use the initials of each plant as a key so they can easily referenced\n  (reduce into (sorted-map)\n          (map-indexed\n            (fn [i v] {(keyword v) ;Childs name will be the keyword in the returned map as to easily attain their plants\n                       (map\n                         #(key-plants (keyword(str/capitalize(str %)))) ;replaces each plant letter with plant name\n                         (reduce into [] (map ;Gets the corresponding cups for that child from each shelf into a coll\n                                           #(take cups-per-row (drop (* cups-per-row i) %)) ;Uses index to drop and take plants\n                                           shelfs)))})\n            children)))\n(defn kindergardeners [children plants shelfs no-of-shelfs cups-per-row]\n  (if (= (count shelfs) (* (count children) cups-per-row no-of-shelfs)) ; Checks to see if the parameters add up\n    (match-plants (sort-by str (map str/capitalize children))  ;Sorts children in alphabetical order as per the spec\n                  plants\n                  (partition (/ (count shelfs)no-of-shelfs) shelfs) ;Split the shelfs into the match plants function so that shelfs can be used on a map function\n                  cups-per-row)\n    \&quot;Wrong number of cups per row and/or number of shelfs\&quot;))\n\n(deftest kindergardeners-test\n         (testing \&quot;Kindergardeners\&quot;\n                  (testing \&quot;with valid data\&quot;\n                           ;Gives answers according to the question\n                           (is (= [\&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Violets\&quot; \&quot;Radishes\&quot;] (:Alice (kindergardeners children plants shelfs 2 2))))\n                           (is (= [\&quot;Clover\&quot; \&quot;Grass\&quot; \&quot;Clover\&quot; \&quot;Clover\&quot;] (:Bob (kindergardeners children plants shelfs 2 2))))\n                           ;If changes the cups per row to 4 and shelfs to 1 then people get sequential sets of 4 plants\n                           (is (= [\&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Clover\&quot; \&quot;Grass\&quot;] (:Alice (kindergardeners children plants shelfs 1 4))))\n                           (is (= [\&quot;Violets\&quot; \&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Violets\&quot;] (:Bob (kindergardeners children plants shelfs 1 4))))\n                           ;Different plants and children\n                           (is (= [\&quot;Chamomile\&quot; \&quot;Strawberry\&quot; \&quot;Chamomile\&quot; \&quot;Poppy\&quot; \&quot;Apple\&quot; \&quot;Rice\&quot;] (:Mya (kindergardeners [\&quot;Brayan\&quot; \&quot;August\&quot; \&quot;Brianna\&quot; \&quot;Mya\&quot; \&quot;Salma\&quot; \&quot;Barrett\&quot; \&quot;Mallory\&quot; \&quot;Jazlynn\&quot; \&quot;Julius\&quot; \&quot;Aliya\&quot;\n                                                                                                                        \&quot;Katelyn\&quot; \&quot;Dereon\&quot; \&quot;Courtney\&quot; \&quot;Christian\&quot; \&quot;Charity\&quot; \&quot;Erica\&quot; \&quot;Miya\&quot; \&quot;Javon\&quot; \&quot;Delilah\&quot; \&quot;Jaiden\&quot;]\n                                                                                                                       [\&quot;Rice\&quot; \&quot;Dandelions\&quot; \&quot;Ivy\&quot; \&quot;Birch\&quot; \&quot;Apple\&quot; \&quot;Poppy\&quot; \&quot;Chamomile\&quot; \&quot;Strawberry\&quot;]\n                                                                                                                       \&quot;IBIRDSPBIBRBPISBPBICCIPDPRIBABICAPSICSDPRRBARDBRPRBADRBBPBCRACBSRIAPBIRPIRBBCPSDSAIRRIPDDBSCIIBAACSAASIDBBDISRBCPAABARCR\&quot;\n                                                                                                                       3 2)))))\n                  (testing \&quot;alternative scenarios\&quot;\n                           ;Two of the same name will only count last instance of the name\n                           (is (= [\&quot;Clover\&quot; \&quot;Grass\&quot; \&quot;Clover\&quot; \&quot;Clover\&quot;] (:Alice (kindergardeners [\&quot;Alice\&quot; \&quot;Alice\&quot; \&quot;Bob\&quot; \&quot;Charlie\&quot; \&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n                                                                                                 \&quot;Harriet\&quot; \&quot;Ileana\&quot; \&quot;Joseph\&quot; \&quot;Kincaid\&quot;] plants shelfs 2 2))))\n                           ;Names in wrong order\n                           (is (= [\&quot;Violets\&quot; \&quot;Radishes\&quot; \&quot;Violets\&quot; \&quot;Radishes\&quot;] (:Alice (kindergardeners [\&quot;Joseph\&quot; \&quot;Kincaid\&quot; \&quot;Larry\&quot;\&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n                                                                                                        \&quot;Harriet\&quot; \&quot;Ileana\&quot;\&quot;Charlie\&quot; \&quot;Alice\&quot; \&quot;Bob\&quot;] plants shelfs 2 2))))\n                           ;Different upper case and lower case shelfs, plants and names\n                           ;Use unsorted and randomly captilised names\n                           (is (= [\&quot;Violets\&quot; \&quot;Clover\&quot; \&quot;Violets\&quot; \&quot;Grass\&quot;] (:Joseph (kindergardeners [\&quot;joseph\&quot; \&quot;Kincaid\&quot; \&quot;Larry\&quot; \&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n                                                                                                    \&quot;Harriet\&quot; \&quot;Ileana\&quot; \&quot;charlie\&quot; \&quot;Alice\&quot; \&quot;bob\&quot;] plants shelfs 2 2))))\n                           ;Randomly captilised list of childrens plants should be same as all capitilised list of plants\n                           (is (= (kindergardeners children plants \&quot;vrcGvvrvCGGccgvRgcVcgCGVvrcccGcRrGvcGCRvVcVgcgCV\&quot; 2 2) (kindergardeners children plants shelfs 2 2)))\n                           ;Still gives names for plant even if non capitlised\n                           (is (= [\&quot;Violets\&quot; \&quot;Clover\&quot; \&quot;Violets\&quot; \&quot;grass\&quot;] (:Joseph (kindergardeners children [\&quot;Violets\&quot; \&quot;grass\&quot; \&quot;Clover\&quot; \&quot;radishes\&quot;] shelfs 2 2)))))\n                  (testing \&quot;with invalid or potentially breaking data\&quot;\n                           ;No shelfs\n                           (is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (kindergardeners children plants shelfs 0 2)))\n                           ;Shelf includes plants not in the list gives nil values\n                           (is (= [\&quot;Violets\&quot; nil \&quot;Violets\&quot; \&quot;Radishes\&quot;] (:Alice (kindergardeners children plants \&quot;VICGVVRVCGGICFVRGCVCFCGVVRCCCGCRIGVFGCRVVCVFCGCV\&quot; 2 2))))\n                           ;No plants means everyone has a collection of nils\n                           (is (= [nil nil nil nil] (:Alice (kindergardeners children [] shelfs 2 2))))\n                           ;No children/shelf of plants means the program will exit early\n                           (is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (kindergardeners children plants [] 2 2)))\n                           (is (= \&quot;Wrong number of cups per row and/or number of shelfs\&quot; (kindergardeners [] plants shelfs 2 2))))))\n\n\n\n;Meteor falls Sub-task 4\n\n;Used to keyword data that may have brackets or spaces that cause them to not keyword properly\n(defn keywordify [string]\n  (keyword(str/replace string #\&quot;[\\)\\(\\s\\,\\'\\n\\/\\:\\@']\&quot; \&quot;\&quot;)))\n\n;Reads the JSON file and handles dates\n(defn my-value-reader [key value]\n  (if (= key :date)\n    (java.sql.Date/valueOf value)\n    value))\n\n;user can enter the URL or full collection into each function for flexibility\n(defn define-data [info]\n  (cond\n    (string? info) (json/read-str (slurp info)\n                                  :value-fn my-value-reader\n                                  :key-fn keyword)\n    (coll? info) info))\n(def info (json/read-str\n            (slurp \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)\n            :value-fn my-value-reader\n            :key-fn keyword))\n;Used to parse the dates that are given in the NASA JSON file\n(defn parse-date-year [x]\n  (.format\n    (java.text.SimpleDateFormat. \&quot;yyyy\&quot;)\n    (.parse\n      (java.text.SimpleDateFormat. \&quot;yyyy-MM-DD\&quot;) x)))\n(defn frequencies-by-key [key data]\n  (frequencies (for [x data]\n                 (if (contains? x key)\n                   (x key)))))\n\n;1. Which year saw the most individual meteor falls?\n(defn most-falls-year [data]\n  (def d (define-data data))\n  (-&gt;&gt;\n    (reduce (fn [m [d v]]\n              (if (some? d)\n                (assoc m (parse-date-year d) v))) ;Parses the date just to show the year\n            {}\n            (frequencies-by-key :year d)) ;Gets the frequencies of each year\n    (sort-by val)\n    last))\n(most-falls-year info)\n\n(deftest Q4-1-test\n         (testing \&quot;Question 4-1. Which year saw the most individual meteor falls?\&quot;\n                  ;Test using the previously downloaded data\n                  (is (=[\&quot;1933\&quot; 16]\n                        (most-falls-year info)))\n                  ;Test using the URL\n                  (is (=[\&quot;1933\&quot; 16]\n                        (most-falls-year \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)))))\n\n\n;2. Which year saw the heaviest collective meteor fall?\n(defn heaviest-collective-fall [data]\n  (def d (define-data data))\n  (-&gt;&gt;\n    ;this merge with function takes each entry in the coll and merges them based on duplicate keys (the year)\n    (apply merge-with (comp +)\n           ;Gets mass of every year in a coll\n           (for [x d]\n             (if (and (contains? x :mass)(contains? x :year))\n               {(keyword (parse-date-year (x :year))) ;parses the date to get just the year\n                (Float/parseFloat (x :mass))})))\n    (sort-by val)\n    last\n    ))\n(heaviest-collective-fall info)\n\n(deftest Q4-2-test\n         (testing \&quot;Question 4-2. Which year saw the heaviest collective meteor fall?\&quot;\n                  ;Test using the previously downloaded data\n                  (is (=[:1947 2.303023E7]\n                        (heaviest-collective-fall info)))\n                  ;Test using the URL\n                  (is (=[:1947 2.303023E7]\n                        (heaviest-collective-fall \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)))))\n\n\n;3. Which type of meteor is the heaviest on average?\n(defn heaviest-type [data]\n  (def d (define-data data))\n  ;Gets a collection of meteorite entry with the class as the key and the mass as the value\n  (def meteorites (filter some? (map\n                                  #(if (and (contains? % :recclass)(contains? % :mass))\n                                     {(keywordify (% :recclass))\n                                      (Float/parseFloat (% :mass))})d)))\n  ;Gets a collection each meteorite class and how many of each there are\n  (def meteorites-freq (frequencies(map\n                                     #(if (and (contains? % :recclass)(contains? % :mass))\n                                        (keywordify (% :recclass))) d)))\n  (-&gt;&gt;\n    (reduce\n      (fn [m [k v]] (assoc m k (/ v (meteorites-freq k))))  ;divide each collective weight of meteor by how many times it occurs to get average\n      {} (apply merge-with (comp +) meteorites)) ;get collective weight of each meteor class using comp and merge-with\n    (sort-by val)\n    last)\n  )\n(heaviest-type info)\n\n(deftest Q4-3-test\n         (testing \&quot;Question 4-3. Which type of meteor is the heaviest on average?\&quot;\n                  ;Test using the previously downloaded data\n                  (is (=[:IronIIAB 3885195.3333333335]\n                        (heaviest-type info)))\n                  ;Test using the URL\n                  (is (=[:IronIIAB 3885195.3333333335]\n                        (heaviest-type \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)))))\n\n\n;4. Which two meteorites are closest together?\n(defn distance-two-points [[x1 y1] [x2 y2]] ;Use pythagoras to find distance between two points\n  (let [dx (- x2 x1), dy (- y2 y1)]\n    (+ (* dx dx) (* dy dy))))\n(defn closest-pair [data]\n  ;creates the co-ordinates for the function to run through\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;)) ((% :geolocation):coordinates)})\n                                           data))))\n  ;runs through all permutations of co-ordinates to find the lowest distance then square roots\n  (Math/sqrt (loop [i 0 j 1 dist 100000000]\n               ;(println i j dist)\n               (if (= i (dec (count vec-co-ords)))\n                 dist ;once i has hit the count of the co-ords then return distance\n                 (let [new-dist (min dist (distance-two-points ;finds the min between the new distance and the old and recurs with the lesser of the two\n                                            (val(first(nth vec-co-ords i)))\n                                            (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))  ;once the second co-ordinate has been ran through agaisnt the first then run again avoiding using the\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n\n;Rather disappointingly the two closest are Galim (a) and Galim (b) which both landed in the exact same space at the same time apparently\n(time (closest-pair info))\n\n(deftest Q4-4-test\n         (testing \&quot;Question 4-4. Which two meteorites are closest together?\&quot;\n                  ;Test using the previously downloaded data\n                  (is (= 0.0\n                         (closest-pair info)))\n                  ;Test using the URL\n                  (is (= 0.0\n                         (closest-pair \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)))))\n\n;5. Find how many years between the first and latest meteorite\n(defn meteorite-range [data]\n  (def d (define-data data))\n  ;Get all the years in the JSON dataset\n  (def years (filter some? (map\n                             #(if (and (contains? % :year))\n                                (Integer/parseInt(parse-date-year (% :year))))d)))\n  (- (apply max years) (apply min years))) ;Using the max and min year we can find out the range of the dataset\n(meteorite-range info)\n\n(deftest Q4-5-test\n         (testing \&quot;Question 4-5. Find how many years between the first and latest meteorite\&quot;\n                  ;Test using the previously downloaded data\n                  (is (= 1152\n                         (meteorite-range info)))\n                  ;Test using the URL\n                  (is (= 1152\n                         (meteorite-range \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)))))&quot;, :offset 19399, :ns &quot;user&quot;} {:command &quot;(closest-pair \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)&quot;, :offset 62, :ns &quot;core.core&quot;} {:command &quot;(defn closest-pair [data]\n  (def d (define-data data))\n  ;creates the co-ordinates for the function to run through\n  (def vec-co-ords (filter some?(into [] (map\n                                           #(if (and (contains? % :name)\n                                                     (contains? % :geolocation)\n                                                     (= (% :fall) \&quot;Fell\&quot;))\n                                              {(keyword (str/replace (% :name) #\&quot;[\\)\\(\\s\\,\\'\\n\\/']\&quot; \&quot;\&quot;)) ((% :geolocation):coordinates)})\n                                           d))))\n  ;runs through all permutations of co-ordinates to find the lowest distance then square roots\n  (Math/sqrt (loop [i 0 j 1 dist 100000000]\n               ;(println i j dist)\n               (if (= i (dec (count vec-co-ords)))\n                 dist ;once i has hit the count of the co-ords then return distance\n                 (let [new-dist (min dist (distance-two-points ;finds the min between the new distance and the old and recurs with the lesser of the two\n                                            (val(first(nth vec-co-ords i)))\n                                            (val(first(nth vec-co-ords j)))))]\n                   (if (= j (dec (count vec-co-ords)))  ;once the second co-ordinate has been ran through agaisnt the first then run again avoiding using the\n                     (recur (inc i) (-&gt; i inc inc) new-dist)\n                     (recur i (inc j) new-dist)))))))\n&quot;, :offset 1466, :ns &quot;core.core&quot;} {:command &quot;(run-tests)&quot;, :offset 10, :ns &quot;core.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.REPL for core">
    <configuration name="REPL for core" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false" temporary="true">
      <module name="core" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="core" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="core" />
      <setting name="path" value="$PROJECT_DIR$/src/core/core.clj" />
      <setting name="namespace" value="" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$/src/core" />
      <method v="2" />
    </configuration>
    <configuration name="core.core" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="core" />
      <setting name="path" value="$PROJECT_DIR$/src/core/core.clj" />
      <setting name="namespace" value="" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$/src/core" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Clojure Application.core" />
      <item itemvalue="Clojure Application.core.core" />
      <item itemvalue="Clojure REPL.REPL for core" />
    </list>
    <recent_temporary>
      <list>
        <item itemvalue="Clojure REPL.REPL for core" />
        <item itemvalue="Clojure Application.core" />
        <item itemvalue="Clojure Application.core.core" />
      </list>
    </recent_temporary>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="c4a3720d-cc46-4ff2-90ff-a29ab3cd4cad" name="Default Changelist" comment="" />
      <created>1571824894533</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1571824894533</updated>
      <workItem from="1571824897604" duration="1084000" />
      <workItem from="1572013307981" duration="621000" />
      <workItem from="1572086152273" duration="7715000" />
      <workItem from="1572168408227" duration="2156000" />
      <workItem from="1572281364766" duration="1208000" />
      <workItem from="1572514454873" duration="2132000" />
      <workItem from="1572817247128" duration="1657000" />
      <workItem from="1572818923761" duration="1725000" />
      <workItem from="1572884276096" duration="771000" />
      <workItem from="1572906117153" duration="1530000" />
      <workItem from="1572960767270" duration="1331000" />
      <workItem from="1573069409690" duration="1801000" />
      <workItem from="1573118685645" duration="14567000" />
      <workItem from="1573401666458" duration="5657000" />
      <workItem from="1573416396406" duration="4734000" />
      <workItem from="1573737729633" duration="3632000" />
      <workItem from="1573817419582" duration="4336000" />
      <workItem from="1573919779368" duration="1806000" />
      <workItem from="1573989203555" duration="599000" />
      <workItem from="1574619936420" duration="1349000" />
      <workItem from="1574940381988" duration="3735000" />
      <workItem from="1575833205387" duration="3825000" />
      <workItem from="1575893057883" duration="5448000" />
      <workItem from="1575977074046" duration="21621000" />
      <workItem from="1576142238122" duration="1624000" />
      <workItem from="1576540644308" duration="3153000" />
      <workItem from="1576543831988" duration="332000" />
      <workItem from="1576544181905" duration="4147000" />
      <workItem from="1578870986843" duration="17808000" />
    </task>
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State>
              <option name="COLUMN_ORDER" />
            </State>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>