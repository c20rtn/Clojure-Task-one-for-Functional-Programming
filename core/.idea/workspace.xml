<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="c4a3720d-cc46-4ff2-90ff-a29ab3cd4cad" name="Default Changelist" comment="" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="ProjectId" id="1SbGU66ACUCRlk5TSbg3oCDIoDv" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="PropertiesComponent">
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="aspect.path.notification.shown" value="true" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="node.js.detected.package.eslint" value="true" />
    <property name="node.js.detected.package.tslint" value="true" />
    <property name="node.js.path.for.package.eslint" value="project" />
    <property name="node.js.path.for.package.tslint" value="project" />
    <property name="node.js.selected.package.eslint" value="(autodetect)" />
    <property name="node.js.selected.package.tslint" value="(autodetect)" />
    <property name="settings.editor.selected.configurable" value="preferences.editor" />
  </component>
  <component name="ReplState" timestamp="1578906278686">{:repl-history {:ide [], :local [{:command &quot;(defn square_list_recur [n]\n  (lazy-seq\n    (if (empty? n)\n      (cons (* (first n)(first n)) (square_list_recur (rest n)))\n      )))\n\n(square_list_recur [1 2 3 4 5 6 7 8 9])&quot;, :offset 174, :ns &quot;core.core&quot;} {:command &quot;(let n [1 2 3 4 5])&quot;, :offset 19, :ns &quot;core.core&quot;} {:command &quot;(let superlist [1 2 3 4 5])&quot;, :offset 27, :ns &quot;core.core&quot;} {:command &quot;(defn square_list_recur [n]\n  (lazy-seq\n    (if (empty? n)\n      (cons (* (first n)(first n)) (square_list_recur (rest n))))))\n\n(square_list_recur [1 2 3 4 5 6 7 8 9])&quot;, :offset 167, :ns &quot;core.core&quot;} {:command &quot;(defn square_list_recur [n]\n  (lazy-seq\n    (if (empty? n)\n      (cons (println (* (first n)(first n))) (square_list_recur (rest n))))))\n\n(square_list_recur [1 2 3 4 5 6 7 8 9])&quot;, :offset 177, :ns &quot;core.core&quot;} {:command &quot;(&gt;= 0 1)&quot;, :offset 8, :ns &quot;core.core&quot;} {:command &quot;(&gt; 0 1)&quot;, :offset 7, :ns &quot;core.core&quot;} {:command &quot;(&lt; 0 1)&quot;, :offset 7, :ns &quot;core.core&quot;} {:command &quot;(&gt; 0 -1)&quot;, :offset 8, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count [amount, dens, den_index]\n  (cond\n    (== amount 0) 1\n    (&gt; 0 n) 0\n    (and (&gt; 0 den_index) (&gt; 0 amount)) 0\n    :else (+ (denomination_count amount dens (dec den_index)) (denomination_count (- amount (get dens den_index)) dens den_index))\n    ))\n(defn dollar_count [amount, dens]\n  (denomination_count amount, dens, (- (count dens) 1))\n  )\n(println (dollar_count 100 [25, 10, 5, 1]))&quot;, :offset 409, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count [amount, dens, den_index]\n  (cond\n    (== amount 0) 1\n    (&gt; 0 amount) 0\n    (and (&gt; 0 den_index) (&gt; 0 amount)) 0\n    :else (+ (denomination_count amount dens (dec den_index)) (denomination_count (- amount (get dens den_index)) dens den_index))\n    ))\n(defn dollar_count [amount, dens]\n  (denomination_count amount, dens, (- (count dens) 1))\n  )\n(println (dollar_count 100 [25, 10, 5, 1]))&quot;, :offset 414, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count [amount, dens, den_index]\n  (cond\n    (== amount 0) 1\n    (&gt; 0 amount) 0\n    (and (&gt; 0 den_index) (&gt; 0 amount)) 0\n    :else (+ (denomination_count amount dens (dec den_index)) (denomination_count (- amount (get dens den_index)) dens den_index))\n    ))\n(defn dollar_count [amount, dens]\n  (denomination_count amount, dens, (- (count dens) 1))\n  )\n(println (dollar_count 4 [1,2,3]))&quot;, :offset 405, :ns &quot;core.core&quot;} {:command &quot;(sort &gt; [1,2,3])&quot;, :offset 16, :ns &quot;core.core&quot;} {:command &quot;(&gt; 0 -1\n   )&quot;, :offset 12, :ns &quot;core.core&quot;} {:command &quot;(or (&gt; 0 -1) (&gt; 0 1))&quot;, :offset 21, :ns &quot;core.core&quot;} {:command &quot;(or (&gt; 0 1) (&gt; 0 1))&quot;, :offset 20, :ns &quot;core.core&quot;} {:command &quot;(SORT &lt; [1 2 3 4 5]\n      )&quot;, :offset 27, :ns &quot;core.core&quot;} {:command &quot;(sort &lt; [1 2 3 4 5])&quot;, :offset 20, :ns &quot;core.core&quot;} {:command &quot;(sort &gt; [1 2 3 4 5])&quot;, :offset 20, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count [amount, dens]\n  (cond\n    (or (empty? dens) (&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n    )\n  )\n(defn dollar_count [amount, dens]\n  (denomination_count amount, (sort &lt; dens))\n  )\n(println (dollar_count 4 [1,2,3]))&quot;, :offset 336, :ns &quot;core.core&quot;} {:command &quot;(defn foo [n]\n  (lazy-seq (cons (first n) (fib (rest n)))))\n(foo [1 3 4 5 8])&quot;, :offset 77, :ns &quot;core.core&quot;} {:command &quot;(defn foo [n]\n  (lazy-seq (cons (first n) (foo (rest n)))))\n(foo [1 3 4 5 8])&quot;, :offset 77, :ns &quot;core.core&quot;} {:command &quot;(defn foo [n]\n  (lazy-seq (cons (first n) (foo (rest n)))))\n(println (foo [1 3 4 5 8])\n         )&quot;, :offset 97, :ns &quot;core.core&quot;} {:command &quot;(defn foo [n]\n  (lazy-seq (cons (first n) (foo (rest n)))))\n\n(println (foo [1 3 4 5 8]))&quot;, :offset 88, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n    )\n  )\n(defn dollar_count [amount, dens]\n  (denomination_count amount, (sort &lt; dens))\n  )\n(println (memoize (dollar_count 100 [1 5 10 25])))&quot;, :offset 351, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n    )\n  )\n(defn dollar_count [amount, dens]\n  (denomination_count amount, (sort &lt; dens))\n  )\n(\n          (dollar_count 100 [1 5 10 25]))&quot;, :offset 344, :ns &quot;core.core&quot;} {:command &quot;\n(def children [\&quot;Alice\&quot; \&quot;Bob\&quot; \&quot;Charlie\&quot; \&quot;David\&quot; \&quot;Eve\&quot; \&quot;Fred\&quot; \&quot;Ginny\&quot;\n               \&quot;Harriet\&quot; \&quot;Ileana\&quot; \&quot;Joseph\&quot; \&quot;Kincaid\&quot; \&quot;Larry\&quot;])\n(def plants [\&quot;Violets\&quot; \&quot;Grass\&quot; \&quot;Clover\&quot; \&quot;Radishes\&quot;])\n(def shelfs \&quot;VRCGVVRVCGGCCGVRGCVCGCGVVRCCCGCRRGVCGCRVVCVGCGCV\&quot;)&quot;, :offset 248, :ns &quot;core.core&quot;} {:command &quot;(defn transform ;gives a key of the starting letter to each item in the list, used to identify plants\n  [coll]\n  (reduce-kv (fn [m k v]\n               (if (empty? v)\n                 m\n                 (assoc m (keyword (str(first v))) v)))\n             {}\n             coll))&quot;, :offset 276, :ns &quot;core.core&quot;} {:command &quot;(def key-plants (transform plants))\n(def split-shelfs (split-at (/ (count shelfs) 2) (vec shelfs)))&quot;, :offset 99, :ns &quot;core.core&quot;} {:command &quot;key-plants&quot;, :offset 10, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n    )\n  )\n(defn dollar_count [amount, dens]\n  (denomination_count amount, (sort &lt; dens))\n  )\n(println (dollar_count 100 [1 5 10 25]))&quot;, :offset 341, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n    )\n  )\n(defn dollar_count [amount, dens]\n  (time(memoize(denomination_count amount, (sort &lt; dens))))\n  )\n(println (dollar_count 100 [1 5 10 25]))&quot;, :offset 356, :ns &quot;core.core&quot;} {:command &quot;\n(println (dollar_count 100 [1 5 10 25]))&quot;, :offset 0, :ns &quot;core.core&quot;} {:command &quot;\n\n\n(println (dollar_count 100 [1 5 10 25]))&quot;, :offset 1, :ns &quot;core.core&quot;} {:command &quot;(println (memoize(dollar_count 100 [1 5 10 25])))&quot;, :offset 49, :ns &quot;core.core&quot;} {:command &quot;(println (memoize(dollar_count 10000 [1 5 10 25])))&quot;, :offset 51, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n    )\n  )\n(defn dollar_count [amount, dens]\n  (time(denomination_count amount, (sort &lt; dens)))\n  )\n(println (dollar_count 100 [1 5 10 25]))&quot;, :offset 347, :ns &quot;core.core&quot;} {:command &quot;\n(memoize(println (dollar_count 5000 [1 5 10 25])))&quot;, :offset 9, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count (memoize (fn [amount, dens]\n                                    (cond\n                                      (or (empty? dens)(&gt; 0 amount)) 0\n                                      (== amount 0) 1\n                                      :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n                                      )))\n  )\n(defn dollar_count [amount, dens]\n  (denomination_count amount, (sort &lt; dens))\n  )\n(println (dollar_count 100 [1 5 10 25]))&quot;, :offset 526, :ns &quot;core.core&quot;} {:command &quot;(defn denomination_count\n  (memoize\n    (fn [amount, dens]\n      (cond\n        (or (empty? dens)(&gt; 0 amount)) 0\n        (== amount 0) 1\n        :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n        ))))\n(defn dollar_count [amount, dens]\n  (time (denomination_count amount, (sort &lt; dens)))\n  )\n(println (dollar_count 100 [1 5 10 25]))&quot;, :offset 386, :ns &quot;core.core&quot;} {:command &quot;(def denomination_count\n  (memoize\n    (fn [amount, dens]\n      (cond\n        (or (empty? dens)(&gt; 0 amount)) 0\n        (== amount 0) 1\n        :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n        ))))\n(def dollar_count [amount, dens]\n  (time (denomination_count amount, (sort &lt; dens)))\n  )\n(println (dollar_count 100 [1 5 10 25]))&quot;, :offset 259, :ns &quot;core.core&quot;} {:command &quot;(println (dollar_count 1000 [1 5 10 25]))&quot;, :offset 41, :ns &quot;core.core&quot;} {:command &quot;(def denomination_count\n  (memoize\n    (fn [amount, dens]\n      (cond\n        (or (empty? dens)(&gt; 0 amount)) 0\n        (== amount 0) 1\n        :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n        ))))\n(defn dollar_count [amount, dens]\n  (time (denomination_count amount, (sort &lt; dens)))\n  )\n(println (dollar_count 100 [1 5 10 25]))&quot;, :offset 385, :ns &quot;core.core&quot;} {:command &quot;(def denomination_count\n  (memoize\n    (fn [amount, dens]\n      (cond\n        (or (empty? dens)(&gt; 0 amount)) 0\n        (== amount 0) 1\n        :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n        ))))\n(defn dollar_count [amount, dens]\n  (time (denomination_count amount, (sort &lt; dens)))\n  )\n(println (dollar_count 500 [1 5 10 25]))&quot;, :offset 385, :ns &quot;core.core&quot;} {:command &quot;(def denomination_count\n  (memoize\n    (fn [amount, dens]\n      (cond\n        (or (empty? dens)(&gt; 0 amount)) 0\n        (== amount 0) 1\n        :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n        ))))\n(defn dollar_count [amount, dens]\n  (time (denomination_count amount, (sort &lt; dens)))\n  )\n(println (dollar_count 10000 [1 5 10 25]))&quot;, :offset 371, :ns &quot;core.core&quot;} {:command &quot;(def denomination_count\n  (memoize\n    (fn [amount, dens]\n      (cond\n        (or (empty? dens)(&gt; 0 amount)) 0\n        (== amount 0) 1\n        :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n        ))))\n(defn dollar_count [amount, dens]\n  (time (denomination_count amount, (sort &lt; dens)))\n  )\n(println (dollar_count 1000 [1 5 10 25]))&quot;, :offset 386, :ns &quot;core.core&quot;} {:command &quot;(def denomination_count\n  (memoize\n    (fn [amount, dens]\n      (cond\n        (or (empty? dens)(&gt; 0 amount)) 0\n        (== amount 0) 1\n        :else (+ (denomination_count amount (rest dens))(denomination_count (- amount (first dens)) dens))\n        ))))\n(defn dollar_count [amount, dens]\n  (time (denomination_count amount, (sort &lt; dens)))\n  )\n(println (dollar_count 2000 [1 5 10 25]))&quot;, :offset 386, :ns &quot;core.core&quot;} {:command &quot;(def info (json/read-str (slurp \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)) :key-fn)&quot;, :offset 89, :ns &quot;core.core&quot;} {:command &quot;(def info (json/read-str (slurp \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)) :key-fn keyword)&quot;, :offset 98, :ns &quot;core.core&quot;} {:command &quot;(def info (json/read-str (slurp \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;):key-fn keyword))&quot;, :offset 97, :ns &quot;core.core&quot;} {:command &quot;:require [clojure.data.json :as json]&quot;, :offset 37, :ns &quot;core.core&quot;} {:command &quot;[clojure.data.json :as json]&quot;, :offset 0, :ns &quot;core.core&quot;} {:command &quot;[org.clojure/data.json \&quot;0.2.7\&quot;]&quot;, :offset 31, :ns &quot;core.core&quot;} {:command &quot;(:require [clojure.data.json :as json])&quot;, :offset 39, :ns &quot;core.core&quot;} {:command &quot;(ns core.core\n  (:require [clojure.data.json :as json]))&quot;, :offset 56, :ns &quot;core.core&quot;} {:command &quot;\n(def info (json/read-str (slurp \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;)) :key-fn keyword)&quot;, :offset 99, :ns &quot;core.core&quot;} {:command &quot;\n(def info (json/read-str (slurp \&quot;https://data.nasa.gov/resource/y77d-th95.json\&quot;) :key-fn keyword))&quot;, :offset 99, :ns &quot;core.core&quot;} {:command &quot;(reduce into {} info)&quot;, :offset 20, :ns &quot;core.core&quot;} {:command &quot;info&quot;, :offset 4, :ns &quot;core.core&quot;} {:command &quot;(into {} (reduce into {} info))&quot;, :offset 7, :ns &quot;core.core&quot;} {:command &quot;(defn denomination-count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination-count amount (rest dens))\n             (denomination-count (- amount (first dens)) dens))))\n;Rebind denomination-count to a memoised version for caching\n(def denomination-count (memoize denomination-count))\n(defn dollar_count\n  [amount coins]\n  ;This map function caches each coin amount from 0, 1, 2,....n\n  ;This means that each previous amount become memoised and subsequent amounts\n  ;speed up as all amounts but the current amount have been cached\n\n  (last (map #(denomination-count % coins) (range (inc amount)))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 100))))&quot;, :offset 725, :ns &quot;core.core&quot;} {:command &quot;(defn denomination-count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination-count amount (rest dens))\n             (denomination-count (- amount (first dens)) dens))))\n;Rebind denomination-count to a memoised version for caching\n(def denomination-count (memoize denomination-count))\n(defn dollar_count\n  [amount coins]\n  ;This map function caches each coin amount from 0, 1, 2,....n\n  ;This means that each previous amount become memoised and subsequent amounts\n  ;speed up as all amounts but the current amount have been cached\n\n  ;  (last (map #(denomination-count % coins) (range (inc amount)))))\n(last (map #(denomination-count % coins) (range 0 (inc amount) 100))))&quot;, :offset 726, :ns &quot;core.core&quot;} {:command &quot;(defn denomination-count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination-count amount (rest dens))\n             (denomination-count (- amount (first dens)) dens))))\n;Rebind denomination-count to a memoised version for caching\n(def denomination-count (memoize denomination-count))\n(defn dollar_count\n  [amount coins]\n  ;This map function caches each coin amount from 0, 1, 2,....n+1\n  ;This means that each previous amount become memoised and subsequent amounts\n  ;speed up exponentially as all amounts but the current amount have been cached\n  ;I have tried many steps in trying to memoise in steps of 1, 100 and 1000 and have timed each in a new REPL\n  ;\n(last (map #(denomination-count % coins) (range 0 (inc amount) 1000))))&quot;, :offset 715, :ns &quot;core.core&quot;} {:command &quot;(defn denomination-count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination-count amount (rest dens))\n             (denomination-count (- amount (first dens)) dens))))\n;Rebind denomination-count to a memoised version for caching\n(def denomination-count (memoize denomination-count))\n(defn dollar_count\n  [amount coins]\n  ;This map function caches each coin amount from 0, 1, 2,....n+1\n  ;This means that each previous amount become memoised and subsequent amounts\n  ;speed up exponentially as all amounts but the current amount have been cached\n  ;I have tried many steps in trying to memoise in steps of 1, 100 and 1000 and have timed each in a new REPL\n  ;\n(last (map #(denomination-count % coins) (range 0 (inc amount) 100))))&quot;, :offset 780, :ns &quot;core.core&quot;} {:command &quot;\&quot;Elapsed time: 1256.0567 msecs\&quot;&quot;, :offset 31, :ns &quot;core.core&quot;} {:command &quot;(defn denomination-count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination-count amount (rest dens))\n             (denomination-count (- amount (first dens)) dens))))\n;Rebind denomination-count to a memoised version for caching\n(def denomination-count (memoize denomination-count))\n(defn dollar_count\n  [amount coins]\n  ;This map function caches each coin amount from 0, 1, 2,....n+1\n  ;This means that each previous amount become memoised and subsequent amounts\n  ;speed up exponentially as all amounts but the current amount have been cached\n  ;I have tried many steps in trying to memoise in steps of 1, 100 and 1000 and have timed each in a new REPL\n  ;Incrementing by\n  (last (map #(denomination-count % coins) (range (inc amount)))))&quot;, :offset 796, :ns &quot;core.core&quot;} {:command &quot;(defn denomination-count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination-count amount (rest dens))\n             (denomination-count (- amount (first dens)) dens))))\n;Rebind denomination-count to a memoised version for caching\n(def denomination-count (memoize denomination-count))\n(defn dollar_count\n  [amount coins]\n  ;This map function caches each coin amount from 0, 1, 2,....n+1\n  ;This means that each previous amount become memoised and subsequent amounts\n  ;speed up exponentially as all amounts but the current amount have been cached\n  ;I have tried many steps in trying to memoise in steps of 1, 100 and 1000 and have timed each in a new REPL\n  ;Incrementing by 1000 can results in a less stable system and can cause stack overflow errors\n  ;Incrementing by 1 is slightly slower than 100\n  (last (map #(denomination-count % coins) (range 0 (inc amount) 10))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 10))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 100))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 1000))))&quot;, :offset 927, :ns &quot;core.core&quot;} {:command &quot;\n(time(dollar_count 100000 [1 5 10 25 50 100]))&quot;, :offset 47, :ns &quot;core.core&quot;} {:command &quot;(defn denomination-count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination-count amount (rest dens))\n             (denomination-count (- amount (first dens)) dens))))\n;Rebind denomination-count to a memoised version for caching\n(def denomination-count (memoize denomination-count))\n(defn dollar_count\n  [amount coins]\n  ;This map function caches each coin amount from 0, 1, 2,....n+1\n  ;This means that each previous amount become memoised and subsequent amounts\n  ;speed up exponentially as all amounts but the current amount have been cached\n  ;I have tried many steps in trying to memoise in steps of 1, 100 and 1000 and have timed each in a new REPL\n  ;Incrementing by 1000 can results in a less stable system and can cause stack overflow errors\n  ;Incrementing by 1 is slightly slower than 10 while 100 is faster than both in large amounts (e.g. 100000 cents)\n  (last (map #(denomination-count % coins) (range (inc amount)))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 10))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 100))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 1000))))\n\n(time(dollar_count 100 [1 5 10 25]))&quot;, :offset 1245, :ns &quot;core.core&quot;} {:command &quot;(defn denomination-count [amount, dens]\n  (cond\n    (or (empty? dens)(&gt; 0 amount)) 0\n    (== amount 0) 1\n    :else (+ (denomination-count amount (rest dens))\n             (denomination-count (- amount (first dens)) dens))))\n;Rebind denomination-count to a memoised version for caching\n(def denomination-count (memoize denomination-count))\n(defn dollar_count\n  [amount coins]\n  ;This map function caches each coin amount from 0, 1, 2,....n+1\n  ;This means that each previous amount become memoised and subsequent amounts\n  ;speed up exponentially as all amounts but the current amount have been cached\n  ;I have tried many steps in trying to memoise in steps of 1, 100 and 1000 and have timed each in a new REPL\n  ;Incrementing by 1000 can results in a less stable system and can cause stack overflow errors\n  ;Incrementing by 1 is slightly slower than 10 while 100 is faster than both in large amounts (e.g. 100000 cents)\n  ;  (last (map #(denomination-count % coins) (range (inc amount)))))\n (last (map #(denomination-count % coins) (range 0 (inc amount) 10))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 100))))\n; (last (map #(denomination-count % coins) (range 0 (inc amount) 1000))))\n\n(time(dollar_count 100 [1 5 10 25]))&quot;, :offset 1247, :ns &quot;core.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.REPL for core">
    <configuration name="REPL for core" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false" temporary="true">
      <module name="core" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="core" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="core" />
      <setting name="path" value="$PROJECT_DIR$/src/core/core.clj" />
      <setting name="namespace" value="" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$/src/core" />
      <method v="2" />
    </configuration>
    <configuration name="core.core" type="ClojureScriptRunConfiguration" factoryName="Clojure Script" temporary="true">
      <module name="core" />
      <setting name="path" value="$PROJECT_DIR$/src/core/core.clj" />
      <setting name="namespace" value="" />
      <setting name="execution" value="INTELLIJ" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="vmparams" value="" />
      <setting name="params" value="" />
      <setting name="workDir" value="$PROJECT_DIR$/src/core" />
      <method v="2" />
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="Clojure REPL.REPL for core" />
        <item itemvalue="Clojure Application.core" />
        <item itemvalue="Clojure Application.core.core" />
      </list>
    </recent_temporary>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="c4a3720d-cc46-4ff2-90ff-a29ab3cd4cad" name="Default Changelist" comment="" />
      <created>1571824894533</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1571824894533</updated>
      <workItem from="1571824897604" duration="1084000" />
      <workItem from="1572013307981" duration="621000" />
      <workItem from="1572086152273" duration="7715000" />
      <workItem from="1572168408227" duration="2156000" />
      <workItem from="1572281364766" duration="1208000" />
      <workItem from="1572514454873" duration="2132000" />
      <workItem from="1572817247128" duration="1657000" />
      <workItem from="1572818923761" duration="1725000" />
      <workItem from="1572884276096" duration="771000" />
      <workItem from="1572906117153" duration="1530000" />
      <workItem from="1572960767270" duration="1331000" />
      <workItem from="1573069409690" duration="1801000" />
      <workItem from="1573118685645" duration="14567000" />
      <workItem from="1573401666458" duration="5657000" />
      <workItem from="1573416396406" duration="4734000" />
      <workItem from="1573737729633" duration="3632000" />
      <workItem from="1573817419582" duration="4336000" />
      <workItem from="1573919779368" duration="1806000" />
      <workItem from="1573989203555" duration="599000" />
      <workItem from="1574619936420" duration="1349000" />
      <workItem from="1574940381988" duration="3735000" />
      <workItem from="1575833205387" duration="3825000" />
      <workItem from="1575893057883" duration="5448000" />
      <workItem from="1575977074046" duration="21621000" />
      <workItem from="1576142238122" duration="1624000" />
      <workItem from="1576540644308" duration="3153000" />
      <workItem from="1576543831988" duration="332000" />
      <workItem from="1576544181905" duration="4147000" />
      <workItem from="1578870986843" duration="3010000" />
    </task>
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="1" />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State>
              <option name="COLUMN_ORDER" />
            </State>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>